<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangquanliu.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>


  <meta name="description" content="迭代器概念与traits编程技法迭代器是一种smart pointer我们为list设计一个迭代器，则有如下">
<meta property="og:type" content="article">
<meta property="og:title" content="STL源码剖析">
<meta property="og:url" content="http://wangquanliu.com/posts/800d7d1c/index.html">
<meta property="og:site_name" content="王权个人博客">
<meta property="og:description" content="迭代器概念与traits编程技法迭代器是一种smart pointer我们为list设计一个迭代器，则有如下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220917201732978-16634170550311.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220917204855810-16634189371212.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220917211848060-16634207290853.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220917225724580-16634266462084.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220917225939967-16634267820065.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918145701304-16634842231261.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918152216237-16634857375022.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/绘图2-16634875647304-16634875665265.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/绘图3-16634875828156.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918161517293-16634889183247.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918172919976-16634933616878.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918173022204-16634934237989.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918173740864-166349386172510.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918174116134-166349407720711.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918174753565-166349447463512.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918181231236-166349595225113.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220918182657558-166349681865114.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220919222749075-16635976702711.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220919224250620-16635985719232.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220920085356368-16636352374571.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220922090758860-16638088801271.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220922092516084-16638099173352.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220922093835348-16638107165363.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220922094019218-16638108202114.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220922220700986-16638556218581.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220922220722442-16638556434132.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220922230241676-16638589625903.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220925153605844-16640913670011.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220925164901821-16640957430692.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220925171710482-16640974317403.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220925173243946-16640983647784.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220925175234334-16640995553605.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220925175758091-16640998789906.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220928223207195-16643755283061.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220928223948012-16643759894172.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220928224731335-16643764524403.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220928224912559-16643765535584.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002181559205-16647057603301.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002182152029-16647061129322.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002184127147-16647072879763.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002185532144-16647081330824.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002185840119-16647083208805.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002185924690-16647083658136.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002190243377-16647085644087.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002190947746-16647089888968.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002191030021-16647090313319.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002195302553-166471158328512.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003131949318-16647743908361.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003132703768-16647748248992.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003133056578-16647750577543.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003134745313-16647760663344.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003135231952-16647763534515.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002192302522-166470978413810.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221002192641135-166471000233611.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003140855674-16647773367916.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003142618496-16647783793657.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003143015154-16647786160468.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003144229126-16647793503319.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003145356460-166478003735310.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003150235184-166478055622012.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003150514433-166478071532513.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003152248525-166478176963214.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003155011678-166478341256315.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221003173237428-166478955836716.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004161812403-16648714932681.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004162148787-16648717104122.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004173222962-16648759440243.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004173404834-16648760463374.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004173639998-16648762013695.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004173718338-16648762397866.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004191752187-16648822733047.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004192243391-16648825644668.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004193023321-16648830243649.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004193140195-166488310112010.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004193707144-166488342835411.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004194834846-166488411607512.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004195404395-166488444547013.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004195613720-166488457492514.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004202034325-166488603569715.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004203111277-166488667210416.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004203129755-166488669095217.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004203249845-166488677162218.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004203338447-166488682004419.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004203628047-166488698937620.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004203645314-166488700653521.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221004203707502-166488702894922.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221005154615702-16649559775411.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221005154647302-16649560082712.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221005154656216-16649560171793.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221005155827733-16649567091324.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221005160216201-16649569372425.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221005160321422-16649570024816.png">
<meta property="og:image" content="http://wangquanliu.com/posts/800d7d1c/image-20221005160412084-16649570531097.png">
<meta property="article:published_time" content="2022-09-17T11:12:42.000Z">
<meta property="article:modified_time" content="2022-10-17T11:11:35.398Z">
<meta property="article:author" content="刘王权">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="STL">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wangquanliu.com/posts/800d7d1c/image-20220917201732978-16634170550311.png">

<link rel="canonical" href="http://wangquanliu.com/posts/800d7d1c/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STL源码剖析 | 王权个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">王权个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">17</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangquanliu.com/posts/800d7d1c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘王权">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王权个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL源码剖析
        </h1>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-17 19:12:42" itemprop="dateCreated datePublished" datetime="2022-09-17T19:12:42+08:00">2022-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-17 19:11:35" itemprop="dateModified" datetime="2022-10-17T19:11:35+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>50k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>46 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="迭代器概念与traits编程技法"><a href="#迭代器概念与traits编程技法" class="headerlink" title="迭代器概念与traits编程技法"></a>迭代器概念与traits编程技法</h1><h2 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h2><p>我们为list设计一个迭代器，则有如下 </p>
<span id="more"></span>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">tempalte &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListItem</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T <span class="title">value</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> _value;&#125;</span><br><span class="line">	<span class="function">ListItem*<span class="title">next</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> _next;&#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T _value;</span><br><span class="line">	ListItem*_next;<span class="comment">//单向链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_front</span><span class="params">(T value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_end</span><span class="params">(T value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(std::ostream&amp;os=std::cout)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ListItem&lt;T&gt;*_end;</span><br><span class="line">ListItem&lt;T&gt;*_front;</span><br><span class="line"><span class="type">long</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt;<span class="comment">//Item可以是单向/双向链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListIter</span>&#123;</span><br><span class="line">Item*ptr;</span><br><span class="line"><span class="built_in">ListIter</span>(Item*p=<span class="number">0</span>):<span class="built_in">ptr</span>(p)&#123;&#125;</span><br><span class="line">Item&amp;<span class="keyword">operator</span>*()<span class="type">const</span>&#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">Item*<span class="keyword">operator</span>-&gt;()<span class="type">const</span>&#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line"></span><br><span class="line">ListIter&amp;<span class="keyword">operator</span>++()&#123;</span><br><span class="line">ptr=ptr-&gt;next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListIter <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">ListIter temp=*<span class="keyword">this</span>;</span><br><span class="line">++*<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ListIter&amp;i)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ptr==i.ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListIter&amp;i)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ptr!=i.ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	List&lt;<span class="type">int</span>&gt;myList;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		myList.<span class="built_in">insert</span>(i);</span><br><span class="line">		myList.<span class="built_in">insert</span>(i+<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	myList.<span class="built_in">display</span>();</span><br><span class="line">	</span><br><span class="line">	ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">begin</span>(myList.<span class="built_in">front</span>());</span><br><span class="line">	ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; end;</span><br><span class="line">	ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; begin;</span><br><span class="line">	ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; iter;</span><br><span class="line">	</span><br><span class="line">	iter=<span class="built_in">find</span>(begin,end,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span>(iter==end)</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;not found&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;found.&quot;</span>&lt;&lt;iter-&gt;<span class="built_in">value</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Traits编程技法"><a href="#Traits编程技法" class="headerlink" title="Traits编程技法"></a>Traits编程技法</h2><p>class template可以用来“萃取”迭代器的特性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个traits，其意义为，如果I定义有自己的value_type，那么通过这个traits的作用，萃取出来的value_type就是I::value_type。有</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">typename</span> <span class="symbol">iterator_traits</span>&lt;<span class="symbol">T</span>&gt;::<span class="symbol">value_type</span> //返回值 </span><br><span class="line"><span class="symbol">func</span>(<span class="symbol">I</span> <span class="symbol">ite</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用此种方法的好处是我们traits拥有一个特化版本</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">iterator_traits</span>&lt;<span class="symbol">T</span>*&gt;&#123; <span class="comment">//偏特化版——迭代器是个原生指针</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220917201732978-16634170550311.png" alt="image-20220917201732978"></p>
<p>其中迭代器相应的型别有能以下五种：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value <span class="keyword">type</span></span><br><span class="line"><span class="type">difference </span><span class="keyword">type</span></span><br><span class="line"><span class="type">pointer</span></span><br><span class="line"><span class="type"></span>reference</span><br><span class="line">iterator catagoly</span><br></pre></td></tr></table></figure>
<p>若想要与STL容器兼容，则需要定义这五种型别。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器型别之一-value-type"><a href="#迭代器型别之一-value-type" class="headerlink" title="迭代器型别之一:value type"></a>迭代器型别之一:value type</h3><p>value type是指迭代器所指对象的类别 。</p>
<h3 id="迭代器型别之二-difference-type"><a href="#迭代器型别之二-difference-type" class="headerlink" title="迭代器型别之二: difference type"></a>迭代器型别之二: difference type</h3><p>difference type为两个迭代器之间的距离，在STL中的count()，其传回值就必须要使用迭代器的difference type:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="selector-tag">I</span>,class T&gt;</span><br><span class="line">typename iterator_traits&lt;<span class="selector-tag">I</span>&gt;::difference_type;<span class="comment">//函数返回型别 </span></span><br><span class="line"><span class="built_in">count</span>(I first,I last,const T&amp;value)&#123;</span><br><span class="line">typename iterator_traits&lt;<span class="selector-tag">I</span>&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line"> <span class="built_in">for</span>(;first!=last;++first)</span><br><span class="line"> 	<span class="built_in">if</span>(*frist==value)++n;</span><br><span class="line"> return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器型别之三：reference-type"><a href="#迭代器型别之三：reference-type" class="headerlink" title="迭代器型别之三：reference type"></a>迭代器型别之三：reference type</h3><p>在C++中，函数要传回左值，以by reference方式进行，当p是个mutable iterators时，如果value type是T，那么*p的型别不就是T，则是T&amp;。</p>
<h3 id="迭代器型别之四：pointer-type"><a href="#迭代器型别之四：pointer-type" class="headerlink" title="迭代器型别之四：pointer type"></a>迭代器型别之四：pointer type</h3><p>现在我们把reference type和pointer type的这两个型别加入traits内，</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">I</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">iterator_traits</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">typedef</span> typename I::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> typename I::<span class="built_in">ref</span>erence <span class="built_in">ref</span>erence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针的&quot;偏特化版&quot;</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">iterator_traits</span>&lt;<span class="symbol">T</span>*&gt;&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">typedef</span> T*pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; <span class="built_in">ref</span>erence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针的pointer-to-const设计的偏特化版</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">iterator_traits</span>&lt;<span class="symbol">const</span> <span class="symbol">T</span>*&gt;&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; <span class="built_in">ref</span>erence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器型别之五：iterator-category"><a href="#迭代器型别之五：iterator-category" class="headerlink" title="迭代器型别之五：iterator_category"></a>迭代器型别之五：iterator_category</h3><p>根据移动特性与施行操作，迭代器被分为五类：</p>
<ul>
<li>Input Iterator：这种迭代器所指的对象，不允许被外界改变，只读。</li>
<li>Output Iterator：唯写。</li>
<li>Forward Iterator：允许“写入型”算法(例如 replace())在此种迭代器所形成的区间上进行读写操作。</li>
<li>Bidirectional Iterator：可双向移动，某些算法需要逆向走访某个迭代器区间(如逆向拷贝某范围内元素)，可使用Bidirectional Iterators。</li>
<li>Random Access Iterator：前四种迭代器都只供应一部分指针算术能力(前三种支持 operator++，第四种再加上operator—)，第五种则涵盖所有指针算法能力，包括p+n，p-n，p[n]，p1-p2，p1&lt;p2。</li>
</ul>
<p><img src="/posts/800d7d1c/image-20220917204855810-16634189371212.png" alt="image-20220917204855810"></p>
<p>拿advance()函数为例，该函数有两个参数，迭代器P和数据n，函数内部将p累进n次，下面有三份定义。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">InputIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">advance_II</span>(<span class="symbol">InputIterator</span>&amp;<span class="symbol">i,<span class="symbol">Distance</span></span> <span class="symbol">n</span>)&#123;</span><br><span class="line">	<span class="comment">//单向，逐一前进</span></span><br><span class="line">	<span class="keyword">while</span>(n--)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">BidirectionalIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">advance_BI</span>(<span class="symbol">BidirectionalIterator</span>&amp;<span class="symbol">i,<span class="symbol">Distance</span></span> <span class="symbol">n</span>)&#123;</span><br><span class="line">	<span class="comment">//双向，逐一前进</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">while</span>(n--)++i;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">while</span>(n++)--i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">advance_RAI</span>(<span class="symbol">RandomAccessIterator</span>&amp;<span class="symbol">i,<span class="symbol">Distance</span></span> <span class="symbol">n</span>)&#123;</span><br><span class="line">	<span class="comment">//双向，跳跃前进</span></span><br><span class="line">	i+=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们有函数运行时才进行选择则有如下做法</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">InputIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">advance</span>(<span class="symbol">InputIterator</span>&amp;<span class="symbol">i,<span class="symbol">Distance</span></span> <span class="symbol">n</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_random_access_iterator(i))</span><br><span class="line">		advance_RAI(i,n);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(is_bidirectional_iterator(i))</span><br><span class="line">		advance_RI(i,n);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		advance_IT(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下为我们在在编译期就确定使用某个版本，运用重载函数机制来达到这个目标。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五个作为标记用的型别(tag types)</span></span><br><span class="line">struct input_iterator_tag&#123;&#125;;</span><br><span class="line">struct output_iterator_tag&#123;&#125;;</span><br><span class="line">struct forward_iterator_tag:<span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line">struct bidirectional_iterator_tag:<span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line">struct random_access_iterator_tag:<span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上术classes只作为标记用</span></span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">InputIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_advance</span>(<span class="symbol">InputIterator</span>&amp;<span class="symbol">i,<span class="symbol">Distance</span></span> <span class="symbol">n,<span class="symbol">input_iterator_tag</span></span>)&#123;</span><br><span class="line">	<span class="comment">//单向，逐一前进</span></span><br><span class="line">	<span class="keyword">while</span>(n--)++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单纯的传递调用函数</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">ForwardIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_advance</span>(<span class="symbol">ForwardIterator</span>&amp;<span class="symbol">i,<span class="symbol">Distance</span></span> <span class="symbol">n,<span class="symbol">forward_iterator_tag</span></span>)&#123;</span><br><span class="line">	<span class="comment">//单纯的进行传递调用</span></span><br><span class="line">	_advance(i,n,input_iterator_tag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">BidiectionalIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_advance</span>(<span class="symbol">BidiectionalIterator</span>&amp;<span class="symbol">i,<span class="symbol">Distance</span></span> <span class="symbol">n,<span class="symbol">bidirectional_iterator_tag</span></span>)&#123;</span><br><span class="line">	<span class="comment">//双向，逐一前进</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">while</span>(n--)++i;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">while</span>(n++)--i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_advance</span>(<span class="symbol">RandomAccessIterator</span>&amp;<span class="symbol">i,<span class="symbol">Distance</span></span> <span class="symbol">n,<span class="symbol">random_access_iterator_tag</span></span>)&#123;</span><br><span class="line">	<span class="comment">//双向，跳跃前进</span></span><br><span class="line">	i+=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用traits机制，从迭代器中推导出类型</span></span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">InputIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">advance</span>(<span class="symbol">InputIterator</span>&amp;<span class="symbol">i,<span class="symbol">Distance</span></span> <span class="symbol">n</span>)&#123;</span><br><span class="line">	_advance(i,n,iterator_traits&lt;InputIterator&gt;::iterator_category());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了满足以上行为，traits须再增加一个相应的型别 </span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">iterator_traits</span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="keyword">typedef</span> typename I::iterator_category iterator_category;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过继承来消除“单纯只做传递调用”的函数</p>
<p><img src="/posts/800d7d1c/image-20220917211848060-16634207290853.png" alt="image-20220917211848060"></p>
<h3 id="std-iterator-的保证"><a href="#std-iterator-的保证" class="headerlink" title="std::iterator 的保证"></a>std::iterator 的保证</h3><p>以distance为例，我们使用消除“单纯只做传递调用”的函数。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">InputIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">iterator_traits</span>&lt;<span class="symbol">InputIterator</span>&gt;::<span class="symbol">difference_type</span></span><br><span class="line"><span class="symbol">_distance</span>(<span class="symbol">InputIterator</span> <span class="symbol">first,<span class="symbol">InputIterator</span></span> <span class="symbol">last,<span class="symbol">input_iterator_tag</span></span>)&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//逐一累计距离 </span></span><br><span class="line">	<span class="keyword">while</span>(first!=last)&#123;</span><br><span class="line">		++first;</span><br><span class="line">		++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">iterator_traits</span>&lt;<span class="symbol">RandomAccessIterator</span>&gt;::<span class="symbol">difference_type</span></span><br><span class="line"><span class="symbol">_distance</span>(<span class="symbol">RandomAccessIterator</span> <span class="symbol">first,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last,<span class="symbol">random_access_iterator_tag</span></span>)&#123;</span><br><span class="line">	<span class="comment">//直接计算差距</span></span><br><span class="line">	<span class="keyword">return</span> last-first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">InputIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">iterator_traits</span>&lt;<span class="symbol">InputIterator</span>&gt;::<span class="symbol">difference_type</span></span><br><span class="line"><span class="symbol">distance</span>(<span class="symbol">InputIterator</span> <span class="symbol">first,<span class="symbol">InputIterator</span></span> <span class="symbol">last</span>)&#123;</span><br><span class="line">	<span class="keyword">typedef</span> typename iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">	<span class="keyword">return</span> _distance(first,last,category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STL提供了一个iterators class如下，如果每个新设计的迭代器都继承自它，则可保证符合STL所需规范。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">Category,<span class="symbol">class</span></span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Distance</span>=<span class="symbol">ptrdiff_t,<span class="symbol">class</span></span> <span class="symbol">Pointer</span>=<span class="symbol">T</span>*,<span class="symbol">class</span> <span class="symbol">Reference</span>=<span class="symbol">T</span>&amp;&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Category iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Distance difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> Pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Reference <span class="built_in">ref</span>erence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">Item</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">ListIter:<span class="symbol">public</span></span> <span class="symbol">std::<span class="symbol">iterator</span></span>&lt;<span class="symbol">std::<span class="symbol">forwared_iterator_tag</span>,<span class="symbol">Item</span></span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iterator源代码完整重列"><a href="#iterator源代码完整重列" class="headerlink" title="iterator源代码完整重列"></a>iterator源代码完整重列</h2><p><img src="/posts/800d7d1c/image-20220917225724580-16634266462084.png" alt="image-20220917225724580"></p>
<p><img src="/posts/800d7d1c/image-20220917225939967-16634267820065.png" alt="image-20220917225939967"></p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><p><img src="/posts/800d7d1c/image-20220918145701304-16634842231261.png" alt="image-20220918145701304"></p>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector定义"><a href="#vector定义" class="headerlink" title="vector定义"></a>vector定义</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//vector嵌套型别定义</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line"><span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"><span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(finish!=end_of_storage)&#123;<span class="comment">//若有备用空间则使用备用空间</span></span><br><span class="line">		<span class="built_in">construct</span>(finish,x);</span><br><span class="line">		++finish;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="comment">//没有就开拓新空间</span></span><br><span class="line">		<span class="built_in">insert_aux</span>(<span class="built_in">end</span>(),x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">	--finish;</span><br><span class="line">	<span class="built_in">destroy</span>(finish);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;<span class="comment">//清除某位置上的元素</span></span><br><span class="line">	<span class="keyword">if</span>(position+<span class="number">1</span>!=<span class="built_in">end</span>())&#123;</span><br><span class="line">		<span class="built_in">copy</span>(position+<span class="number">1</span>,finish,position);<span class="comment">//把position后续的位置逐一往前移动一个，并进行覆盖</span></span><br><span class="line">		--finish;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">destory</span>(finish);</span><br><span class="line">	<span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">iterator start;<span class="comment">//表示目前使用空间的头</span></span><br><span class="line">iterator finish;<span class="comment">//表示目前使用空间的尾</span></span><br><span class="line">iterator end_of_storage;<span class="comment">//表示目前可用空间的尾</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220918152216237-16634857375022.png" alt="image-20220918152216237"></p>
<h3 id="vector的构造与内存管理"><a href="#vector的构造与内存管理" class="headerlink" title="vector的构造与内存管理"></a>vector的构造与内存管理</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;<span class="title">T</span>,<span class="title">Alloc</span>&gt;::<span class="title">insert_aux</span>(<span class="title">iterator</span> <span class="title">position</span>,<span class="title">const</span> <span class="title">T</span>&amp;<span class="title">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(finish!=end_of_strong)&#123;<span class="comment">//若还有备用空间</span></span><br><span class="line">		<span class="comment">//在备用空间起始处构造一个元素，并以vector最后一个元素为其初值</span></span><br><span class="line">		construct(finish,*(finish<span class="number">-1</span>));</span><br><span class="line">		++finish;</span><br><span class="line">		T x_copy=x;</span><br><span class="line">		copy_backward(position,finish<span class="number">-2</span>,finish<span class="number">-1</span>);</span><br><span class="line">		*postion=x_copy;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//无备用空间</span></span><br><span class="line">		const size_type old_size=size();</span><br><span class="line">		const size_type len=old_size!=<span class="number">0</span>?<span class="number">2</span>*old_size:<span class="type">1</span>;</span><br><span class="line">		<span class="comment">//若空间大小为0，则配置1个元素大小</span></span><br><span class="line">		<span class="comment">//如果原大小不为0，则配置原大小的两倍</span></span><br><span class="line">		<span class="comment">//前半段用来放置原数据，后半段准备用来旋转新数据</span></span><br><span class="line">		</span><br><span class="line">		iterator <span class="keyword">new</span><span class="type">_start</span>=data_allocator:<span class="type"></span>:allocate(len);<span class="comment">//实际配置</span></span><br><span class="line">		iterator <span class="keyword">new</span><span class="type">_finish</span>=<span class="keyword">new</span><span class="type">_start</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//将原数据拷贝到新的空间</span></span><br><span class="line">			<span class="keyword">new</span><span class="type">_finish</span>=uninitialized_copy(start,position,<span class="keyword">new</span><span class="type">_start</span>);</span><br><span class="line">			<span class="comment">//为新元素设定初始值为x</span></span><br><span class="line">			construct(<span class="keyword">new</span><span class="type">_finish</span>,x);</span><br><span class="line">			++<span class="keyword">new</span><span class="type">_finish</span>;</span><br><span class="line">			<span class="comment">//将安插点的原内容也拷贝过来</span></span><br><span class="line">			<span class="keyword">new</span><span class="type">_finish</span>=uninitialized_copy(position,finish,<span class="keyword">new</span><span class="type">_finish</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">			...	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//析构释放原vector</span></span><br><span class="line">		destory(begin(),end());</span><br><span class="line">		deallocate();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//调整迭代器</span></span><br><span class="line">		start=<span class="keyword">new</span><span class="type">_start</span>;</span><br><span class="line">		finish=<span class="keyword">new</span><span class="type">_finish</span>;</span><br><span class="line">		end_of_storage=<span class="keyword">new</span><span class="type">_start</span>+len;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有备用空间时，示意图如下 </p>
<p><img src="/posts/800d7d1c/绘图2-16634875647304-16634875665265.png" alt="绘图2"></p>
<p><img src="/posts/800d7d1c/绘图3-16634875828156.png" alt="绘图3"></p>
<p>当无备用空间时，先扩展空间，再复制前半段的数据，再插入值，再复制后半段的数据。</p>
<h3 id="vector的元素操作：pop-back-erase-clear-insert"><a href="#vector的元素操作：pop-back-erase-clear-insert" class="headerlink" title="vector的元素操作：pop_back,erase,clear,insert"></a>vector的元素操作：pop_back,erase,clear,insert</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//将尾端元素拿掉，并调整大小</span><br><span class="line">void pop_back()&#123;</span><br><span class="line">	--finish;	//将尾端标记往前移动一格</span><br><span class="line">	destory(finish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清除erase[<span class="built_in">first</span>,<span class="built_in">last</span>)中所有元素</span><br><span class="line">iterator erase(iterator <span class="built_in">first</span>,iterator <span class="built_in">last</span>)&#123;</span><br><span class="line">	iterator i=<span class="built_in">copy</span>(<span class="built_in">last</span>,finish,<span class="built_in">first</span>);//把[<span class="built_in">last</span>,finish]的元素移动到头</span><br><span class="line">	destory(i,finish);</span><br><span class="line">	finish=finish-(<span class="built_in">last</span>-<span class="built_in">first</span>);</span><br><span class="line">	<span class="built_in">return</span> <span class="built_in">first</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清除某个位置上的元素</span><br><span class="line">iterator erase(iterator <span class="built_in">position</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">position</span>+<span class="number">1</span>!=end())</span><br><span class="line">		<span class="built_in">copy</span>(<span class="built_in">position</span>+<span class="number">1</span>,finish,<span class="built_in">position</span>);</span><br><span class="line">	--finish;</span><br><span class="line">	destory(finish);</span><br><span class="line">	<span class="built_in">return</span> <span class="built_in">position</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear()&#123;erase(begin(),end());&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220918161517293-16634889183247.png" alt="image-20220918161517293"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从position开始,插入n个元素，元素初值为x</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">vector</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span></span>&gt;::<span class="symbol">insert</span>(<span class="symbol">iterator</span> <span class="symbol">position,<span class="symbol">size_type</span></span> <span class="symbol">n,<span class="symbol">const</span></span> <span class="symbol">T</span>&amp;<span class="symbol">x</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(size_type(end_of_storage-finish)&gt;=n)&#123;</span><br><span class="line">			<span class="comment">//备用空间大于等于&quot;新增元素个数&quot;</span></span><br><span class="line">			T x_copy=x;</span><br><span class="line">			<span class="comment">//以下计算插入点之后的现有元素个数</span></span><br><span class="line">			<span class="keyword">const</span> size_type elems_after=finish-position;</span><br><span class="line">			iterator old_finish=finish;</span><br><span class="line">			<span class="keyword">if</span>(elems_after&gt;n)&#123;</span><br><span class="line">				<span class="comment">//插入点之后的现有元素大于&quot;新增元素个数&quot;</span></span><br><span class="line">				uninitialized_copy(finish-n,finish,finish);<span class="comment">//后移finish-n个元素，为插入元素让出位置		finish+=n;</span></span><br><span class="line">				copy_backward(position,old_finish-n,old_finish);<span class="comment">//拷贝</span></span><br><span class="line">				fill(position,position+n,x_copy);<span class="comment">//从插入点开始填入新值</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">//插入点之后的现有元素个数小于等于新增元素个数 </span></span><br><span class="line">				uninitialize_fill_n(finish,n-elems_after,x_copy);<span class="comment">//在结尾处，去初始化n-elems_after个元素</span></span><br><span class="line">				finish+=n-elems_after;</span><br><span class="line">				uninitialize_copy(position,old_finish,finish);<span class="comment">//后移拷贝</span></span><br><span class="line">				finish+=elems_after;</span><br><span class="line">				fill(position,old_finish,x_copy);<span class="comment">//去赋初始值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//备用空间小于&quot;新增元素个数 &quot;</span></span><br><span class="line">			<span class="comment">//首先决定新长度,旧长度的两倍，或旧长度+新增元素个数 </span></span><br><span class="line">			<span class="keyword">const</span> size_type old_size=size();</span><br><span class="line">			<span class="keyword">const</span> size_type len=old_size+max(old_size,n);</span><br><span class="line">			<span class="comment">//以下配置新的vector空间</span></span><br><span class="line">			iterator new_start=data_allocator::allocate(len);</span><br><span class="line">			iterator new_finish=new_start;</span><br><span class="line">			<span class="comment">//以下首先将旧vector的插入点之前的元素复制到新空间</span></span><br><span class="line">			new_finish=uinitialized_copy(start,position,new_start);</span><br><span class="line">			<span class="comment">//以下再将新增元素填入新空间</span></span><br><span class="line">			new_finish=uninitialized_fill_n(new_finish,n,x);</span><br><span class="line">			<span class="comment">//以下再新旧vector的插入点之后的元素复制到新空间</span></span><br><span class="line">			new_finish=uninitialized_copy(position,finish,new_finish);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220918172919976-16634933616878.png" alt><img src="/posts/800d7d1c/image-20220918173022204-16634934237989.png" alt="image-20220918173022204"></p>
<h2 id="List容器"><a href="#List容器" class="headerlink" title="List容器"></a>List容器</h2><h3 id="list节点"><a href="#list节点" class="headerlink" title="list节点"></a>list节点</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list节点结构:</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">_list_node</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">void</span>*<span class="built_in">void</span>_pointer;</span><br><span class="line">	<span class="built_in">void</span>_pointer prev;<span class="comment">//指向上一节点</span></span><br><span class="line">	<span class="built_in">void</span>_pointer next;<span class="comment">//指向下一节点</span></span><br><span class="line">	T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220918173740864-166349386172510.png" alt="image-20220918173740864"></p>
<h3 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h3><p><img src="/posts/800d7d1c/image-20220918174116134-166349407720711.png" alt="image-20220918174116134"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Ref,<span class="symbol">class</span></span> <span class="symbol">Ptr</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">_list_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> _list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref <span class="built_in">ref</span>erence;</span><br><span class="line">	<span class="keyword">typedef</span> _list_node&lt;T&gt;*link_type;</span><br><span class="line">	<span class="keyword">typedef</span> size_t size_type;</span><br><span class="line">	<span class="keyword">typedef</span> ptrdiff_t difference_type;</span><br><span class="line">	</span><br><span class="line">	link_type node;<span class="comment">//指向List节点</span></span><br><span class="line">	</span><br><span class="line">	self&amp;operator++()&#123;</span><br><span class="line">		node=(link_type)(*(node).next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	self operator++(<span class="built_in">int</span>)&#123;</span><br><span class="line">		self temp=*<span class="keyword">this</span>;</span><br><span class="line">		++*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	self&amp; operator--()&#123;</span><br><span class="line">		node=(link_type)((*node).prev);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	self operator--()&#123;</span><br><span class="line">		self temp=*<span class="keyword">this</span>;</span><br><span class="line">		--*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>list的结构是个环状双向链表</p>
<p><img src="/posts/800d7d1c/image-20220918174753565-166349447463512.png" alt="image-20220918174753565"></p>
<h3 id="list的元素操作"><a href="#list的元素操作" class="headerlink" title="list的元素操作"></a>list的元素操作</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入一个节点，作为头节点</span></span><br><span class="line"><span class="built_in">void</span> push_front(<span class="keyword">const</span> T&amp;x)&#123;insert(begin(),x);&#125;</span><br><span class="line"><span class="comment">//插入一个节点，作为尾节点</span></span><br><span class="line"><span class="built_in">void</span> push_back(<span class="keyword">const</span> T&amp;x)&#123;insert(end(),x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除迭代器position所指的节点</span></span><br><span class="line">iterator erase(iterator position)&#123;</span><br><span class="line">	link_type next_node=link_type(position.node-&gt;next);<span class="comment">//保存上一节点</span></span><br><span class="line">	link_type prev_node=link_type(position.node-&gt;prev);<span class="comment">//保存下一节点</span></span><br><span class="line">	prev_node-&gt;next=next_node;<span class="comment">//使上一节点的下一节点指向当前节点的下一节点</span></span><br><span class="line">	next_node-&gt;prev=prev_node;<span class="comment">//使下一节点的上一节点指向当前节点的上一节点</span></span><br><span class="line">	destroy_node(position.node);</span><br><span class="line">	<span class="keyword">return</span> iterator(next_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除头节点</span></span><br><span class="line"><span class="built_in">void</span> pop_front()&#123;erase(begin());&#125;</span><br><span class="line"><span class="comment">//移除尾节点</span></span><br><span class="line"><span class="built_in">void</span> pop_back()&#123;</span><br><span class="line">	iterator temp=end();</span><br><span class="line">	erase(--temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除所有节点</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">list</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span></span>&gt;::<span class="symbol">clear</span>()&#123;</span><br><span class="line">	link_type cur=(link_type)node-&gt;next;<span class="comment">//begin()//排除头节点</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=node)&#123;<span class="comment">//遍历节点</span></span><br><span class="line">		link_type temp=cur;</span><br><span class="line">		cur=(link_type)cur-&gt;next;</span><br><span class="line">		destroy_node(temp);<span class="comment">//销毁一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//恢复node原始状态</span></span><br><span class="line">	node-&gt;next=node;</span><br><span class="line">	node-&gt;prev=node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数值为value之所有元素移除</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">list</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span></span>&gt;::<span class="symbol">remove</span>(<span class="symbol">const</span> <span class="symbol">T</span>&amp;<span class="symbol">value</span>)&#123;</span><br><span class="line">	iterator first=begin();</span><br><span class="line">	iterator last=end();</span><br><span class="line">	<span class="keyword">while</span>(first!=last)&#123; <span class="comment">//遍历每一个节点</span></span><br><span class="line">		iterator next=first;</span><br><span class="line">		++next;</span><br><span class="line">		<span class="keyword">if</span>(*first==value)erase(first);<span class="comment">//移除</span></span><br><span class="line">		first=next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220918181231236-166349595225113.png" alt="image-20220918181231236"></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//将[first<span class="built_in">,last</span>)内所有元素移动<span class="built_in">到position</span>之前</span><br><span class="line">void transfer(iterator<span class="built_in"> position</span>,iterator first,iterator<span class="built_in"> last</span>)&#123;</span><br><span class="line">	//过程分为两部，<span class="number">1</span>为先取出[first<span class="built_in">,last</span>)链表，<span class="number">2</span>再把[first<span class="built_in">,last</span>)缝合<span class="built_in">进position</span></span><br><span class="line">	<span class="keyword">if</span><span class="built_in">(position</span>!<span class="built_in">=last</span>)&#123;</span><br><span class="line">		(*(link_type)((<span class="built_in">*last</span>.<span class="type">node</span>).prev))).<span class="keyword">next</span><span class="built_in">=position</span>.<span class="type">node</span>;//<span class="built_in">使last</span>的上一节点的下一节点指<span class="built_in">向position</span></span><br><span class="line">		(*(link_type)((*frist.<span class="type">node</span>).prev))).<span class="keyword">next</span><span class="built_in">=last</span>.<span class="type">node</span>;//使frist的上一节点的下一节点指<span class="built_in">向last</span>，因为不会移<span class="built_in">动last</span></span><br><span class="line">		(*(link_type)((<span class="built_in">*position</span>.<span class="type">node</span>).prev))).<span class="keyword">next</span>=frist.<span class="type">node</span>;//<span class="built_in">使position</span>节点的上一节点的下一节点指向first</span><br><span class="line">		link_type temp=link_type((<span class="built_in">*position</span>.<span class="type">node</span>).prev);</span><br><span class="line">		(<span class="built_in">*position</span>.<span class="type">node</span>).prev=(<span class="built_in">*last</span>.<span class="type">node</span>).prev;</span><br><span class="line">		(<span class="built_in">*last</span>.<span class="type">node</span>).prev=(*frist.<span class="type">node</span>).prev;</span><br><span class="line">		(*first.<span class="type">node</span>).prev=temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220918182657558-166349681865114.png" alt="image-20220918182657558"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//merge()将x合并到*this身上，两个list的内容必须要先经过递增排序 </span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">list</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span></span>&gt;::<span class="symbol">merge</span>(<span class="symbol">list</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span></span>&gt;&amp;<span class="symbol">x</span>)&#123;</span><br><span class="line">	iterator first1=begin();</span><br><span class="line">	iterator last1=end();</span><br><span class="line">	iterator first2=x.begin();</span><br><span class="line">	iterator last2=x.end();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注意，前提是，两个lists都已递增排序 </span></span><br><span class="line">	<span class="keyword">while</span>(first1!=last1 &amp;&amp; first2!=last2)</span><br><span class="line">		<span class="keyword">if</span>(*frist2&lt;*frist1)&#123;<span class="comment">//如果frist2中的元素小于first1中某个节点，就把frist2的元素持续插入first中</span></span><br><span class="line">			iterator next=first2;</span><br><span class="line">			transfer(first1,first2,++next);</span><br><span class="line">			first2=next;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">			++first1;</span><br><span class="line">	<span class="keyword">if</span>(first2!=last2)transfer(last1,first2,last2);<span class="comment">//若frist2中还有元素大于first1中最大的元素，则插入first2中的剩余元素到first1中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reserve将*this的内容逆向重置</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">list</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span></span>&gt;::<span class="symbol">reverse</span>()&#123;</span><br><span class="line">	<span class="comment">//如果是空链表，或仅有一个元素，就不进行任何操作</span></span><br><span class="line">	<span class="keyword">if</span>(node-&gt;next==node||link_type(node-&gt;next)-&gt;next==node)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	iterator first=begin();</span><br><span class="line">	++first;</span><br><span class="line">	<span class="keyword">while</span>(first!=end)&#123;</span><br><span class="line">		iterator old=first;</span><br><span class="line">		++first;</span><br><span class="line">		transfer(begin(),old,first);<span class="comment">//持续插入头节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><p>deque是一种双向开口的连续线性空间，双向开口指在头尾两端分别做元素的插入和删除操作。</p>
<p><img src="/posts/800d7d1c/image-20220919222749075-16635976702711.png" alt="image-20220919222749075"></p>
<p>deque与vector的最大差异，一在于deque允许于常数时间内对起头端进行元素的插入或移除操作。二在于deque没有所谓容量观念，因为它是动态地以分段连接空间组合而成，随时可以增加一段新的空间并链接起来。</p>
<h3 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h3><p>deque采用一块所为的map作为主控。这里所谓的map是一小块连续空间，其中每个元素都是指针，指向另一段连续线性空间，称为缓冲区，缓冲区才是deque的储存空间主体。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc</span>=<span class="symbol">alloc,<span class="symbol">size_t</span></span> <span class="symbol">BUfsiz</span>=<span class="symbol">0</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">deque</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type*pointer;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//元素指针的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> pointer*map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	map_pointer map;<span class="comment">//指向Map,Map是块连续空间，其内每个元素都是一个指针(称为节点),指向一块缓冲区</span></span><br><span class="line">	size_type map_size;<span class="comment">//Map内可容纳多少指针</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220919224250620-16635985719232.png" alt="image-20220919224250620"></p>
<h3 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Ref,<span class="symbol">class</span></span> <span class="symbol">Ptr,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">_deque_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _deque_iterator&lt;T,T&amp;,T*,BufSize&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> _deque_iteartor&lt;T,<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T*,BufSize&gt;const_iterator;</span><br><span class="line">	static size_t buffer_size()&#123;<span class="keyword">return</span> _deque_buf_size(BufSize,sizeof(T));&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref <span class="built_in">ref</span>erence;</span><br><span class="line">	<span class="keyword">typedef</span> size_t size_type;</span><br><span class="line">	<span class="keyword">typedef</span> ptrdiff_t difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T**map_pointer;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">typedef</span> _deque_iterator self;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//保持与容器的联结</span></span><br><span class="line">	T*cur;<span class="comment">//此迭代器所指之缓冲区中的现行元素</span></span><br><span class="line">	T*frist;<span class="comment">//此迭代器所指之缓冲区的头</span></span><br><span class="line">	T*last;<span class="comment">//此迭代器所指之缓冲区的尾(含备用空间)</span></span><br><span class="line">	map_pointer node;<span class="comment">//指向管控中心</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220920085356368-16636352374571.png" alt="image-20220920085356368"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳过一个缓冲区</span></span><br><span class="line">void set_node(map_pointer new_node)&#123;</span><br><span class="line">	node=new_node;</span><br><span class="line">	first=*new_node;</span><br><span class="line">	last=first+difference_type(buffer_size);</span><br><span class="line">&#125;</span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> difference_type(buffer_size()*(node-x.node-<span class="number">1</span>)+(cur-first)+(x.last-x.cur));</span><br><span class="line">	<span class="comment">//返回相隔多个元素</span></span><br><span class="line">&#125;</span><br><span class="line">self&amp;<span class="keyword">operator</span>++()&#123;</span><br><span class="line">	++cur;<span class="comment">//切换至下一元素</span></span><br><span class="line">	<span class="keyword">if</span>(cur==last)&#123;<span class="comment">//如果已达到所在缓冲区的尾端</span></span><br><span class="line">		set_node(node+<span class="number">1</span>);<span class="comment">//切换至下一节点</span></span><br><span class="line">		cur=first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self&amp;<span class="keyword">operator</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span>(cur==first)&#123;</span><br><span class="line">		set_node(node-<span class="number">1</span>);<span class="comment">//切换至前一节点</span></span><br><span class="line">		cur=last;</span><br><span class="line">	&#125;</span><br><span class="line">	--cur;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下实现随机存放,迭代器可以直接跳跃N个距离</span></span><br><span class="line">slef&amp;<span class="keyword">operator</span>+=(difference_type n)&#123;</span><br><span class="line">	difference_type offset=n+(cur-first);<span class="comment">//偏移n个距离 </span></span><br><span class="line">	<span class="keyword">if</span>(offset&gt;<span class="number">0</span>&amp;&amp;offset&lt;difference_type(buffer_size()))&#123;</span><br><span class="line">		<span class="comment">//目标位置在同一缓冲区</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//目标位置不在同一缓冲区</span></span><br><span class="line">		difference_type node_offset=offset&gt;<span class="number">0</span>?offset/difference_type(buffer_size()):</span><br><span class="line">									-difference_type((-offset-<span class="number">1</span>)/buffer_size())-<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//切换至正确的节点</span></span><br><span class="line">		set_node(node+node_offset);</span><br><span class="line">		<span class="comment">//切换至正确元素</span></span><br><span class="line">		cur=first+(offset-node_offset*difference_type(buffer_size()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc</span>=<span class="symbol">alloc,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>=<span class="symbol">0</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">deque</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T value_type;</span><br><span class="line">		<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">		<span class="keyword">typedef</span> size_t size_type;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> _deque_iterator&lt;T,T&amp;,T*,BufSize&gt;iterator;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="comment">//元素指针的指针</span></span><br><span class="line">		<span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		iterator start;<span class="comment">//表现第一个节点</span></span><br><span class="line">		iterator finish;<span class="comment">//表现最后一个节点</span></span><br><span class="line">		</span><br><span class="line">		map_pointer map;<span class="comment">//指向map,map是块连续空间</span></span><br><span class="line">						<span class="comment">//其每个元素都是个指针，指向一个节点(缓冲区)</span></span><br><span class="line">		size_type map_size;<span class="comment">//map内有多少个指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">deque</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span>,<span class="symbol">BufSize</span></span>&gt;::<span class="symbol">fill_initialize</span>(<span class="symbol">size_type</span> <span class="symbol">n,<span class="symbol">const</span></span> <span class="symbol">value_type</span>&amp;<span class="symbol">value</span>)&#123;</span><br><span class="line">	create_map_and_nodes(n);<span class="comment">//把deque的结构都产生并安排好</span></span><br><span class="line">	map_pointer cur;</span><br><span class="line">	<span class="comment">//为每个节点的缓冲区设定初值</span></span><br><span class="line">	<span class="keyword">for</span>(cur=start.node;cur&lt;finish.node;++cur)&#123;</span><br><span class="line">		uninitialized_fill(*cur,*cur+buffer_size(),value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后一个节点，因为尾端可能有备用空间，不必设置初值</span></span><br><span class="line">	uninitialize_fill(finish.first,finish.cur,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create_map_and_nodes()负责产生并安排好deque结构 </span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">deque</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span>,<span class="symbol">BufSize</span></span>&gt;::<span class="symbol">create_map_and_nodes</span>(<span class="symbol">size_type</span> <span class="symbol">num_elements</span>)&#123;</span><br><span class="line">	<span class="comment">//需要的节点数=(元素个数/每个缓冲区可容纳的元素个数)+1</span></span><br><span class="line">	<span class="comment">//如果刚好整除，会多配一个节点</span></span><br><span class="line">	size_type num_nodes=num_elements/buffer_size()+<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一个map要管理几个节点,最少8个，最多为所需节点数+2</span></span><br><span class="line">	<span class="comment">//前后各预留一个，扩充时使用</span></span><br><span class="line">	map_size=max(initial_map_size(),num_nodes+<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//配置出一个具有map_size个节点的map</span></span><br><span class="line">	map=map_allocator::allocate(map_size);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//以下令nstart和nfinish指向所拥有之全部节点的最中央区域</span></span><br><span class="line">	<span class="comment">//保存在最中央，可使头尾端的扩充能量一样大，每个节点对应一个缓冲区</span></span><br><span class="line">	map_pointer nstart=map+(map_size-num_nodes)/<span class="number">2</span>;<span class="comment">//在中间位置</span></span><br><span class="line">	map_pointer nfinish=nstart+num_nodes+<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	map_pointer cur;</span><br><span class="line">	<span class="comment">//为map内的每个现用节点配置缓冲区。所有缓冲区加起来就是deque的可用空间</span></span><br><span class="line">	<span class="keyword">for</span>(cur=nstart;cur&lt;=nfinish;++cur)&#123;</span><br><span class="line">		*cur=allocate_node();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	start.set_node(nstart);</span><br><span class="line">	finish.set_node(nfinish);</span><br><span class="line">	start.cur=start.first;</span><br><span class="line">	<span class="comment">//指向最后一个未装满元素的缓冲区</span></span><br><span class="line">	finish.cur=finish.first+num_elements%buffer_size();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220922090758860-16638088801271.png" alt="image-20220922090758860"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> push_back(<span class="keyword">const</span> value_type&amp;t)&#123;</span><br><span class="line">	<span class="keyword">if</span>(finish.cur!=finish.last<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="comment">//最后缓冲区尚有两个(含)以上的元素备用空间</span></span><br><span class="line">		construct(finish.cur,t);<span class="comment">//直接在备用空间上构造元素</span></span><br><span class="line">		++finish.cur;<span class="comment">//调整使用缓冲区的状态</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//最后缓冲区只剩一个元素备用空间</span></span><br><span class="line">		push_back_aux(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">deque</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span>,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>&gt;::<span class="symbol">push_back_aux</span>(<span class="symbol">const</span> <span class="symbol">value_type</span>&amp;<span class="symbol">t</span>)&#123;</span><br><span class="line">	value_type t_copy=t;</span><br><span class="line">	reserve_map_at_back();<span class="comment">//若符合某种条件则必须重新换一个map</span></span><br><span class="line">	*(finish.node+<span class="number">1</span>)=allocate_node();<span class="comment">//配置一个新节点(缓冲区)，调整中控器</span></span><br><span class="line">	construct(finish.cur,t_copy);<span class="comment">//针对标的元素设值</span></span><br><span class="line">	finish.set_node(finish.node+<span class="number">1</span>);<span class="comment">//改变finish，令其指向新节点</span></span><br><span class="line">	finish.cur=finish.first;<span class="comment">//设定finish的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220922092516084-16638099173352.png" alt="image-20220922092516084"></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void push<span class="constructor">_front(<span class="params">const</span> <span class="params">value_type</span>&amp;<span class="params">t</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start.cur!=start.first)&#123;<span class="comment">//第一缓冲区尚有备用空间</span></span><br><span class="line">		construct(start.cur-<span class="number">1</span>,t);<span class="comment">//直接在备用空间上构造元素</span></span><br><span class="line">		--start.cur;<span class="comment">//调整第一缓冲区的使用状态</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		push<span class="constructor">_front_aux(<span class="params">t</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当第一缓冲区没有备用元素时才会调用</span></span><br><span class="line">template&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Alloc,size_t BufSize&gt;</span><br><span class="line">void deque&lt;T,<span class="keyword">class</span> Alloc,size_t BufSize&gt;::push<span class="constructor">_front_aux(<span class="params">const</span> <span class="params">value_type</span>&amp;<span class="params">t</span>)</span>&#123;</span><br><span class="line">	value_type t_copy=t;</span><br><span class="line">	reserve<span class="constructor">_map_at_front()</span>;<span class="comment">//若符合某种条件则必须重新换一个map</span></span><br><span class="line">	*(start.node-<span class="number">1</span>)=allocate<span class="constructor">_node()</span>;<span class="comment">//配置一个新节点</span></span><br><span class="line">	start.set<span class="constructor">_node(<span class="params">start</span>.<span class="params">node</span>-1)</span>;<span class="comment">//改变start,令其指向新节点</span></span><br><span class="line">	start.cur=start.last-<span class="number">1</span>;<span class="comment">//设定start的状态</span></span><br><span class="line">	construct(start.cur,t_copy);<span class="comment">//针对标的元素设值</span></span><br><span class="line">	</span><br><span class="line">	start.set<span class="constructor">_node(<span class="params">start</span>.<span class="params">node</span>+1)</span>;</span><br><span class="line">	start.cur=start.first;</span><br><span class="line">	deallcoate<span class="constructor">_node(<span class="operator">*</span>(<span class="params">start</span>.<span class="params">node</span>-1)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220922093835348-16638107165363.png" alt="image-20220922093835348"></p>
<p><img src="/posts/800d7d1c/image-20220922094019218-16638108202114.png" alt="image-20220922094019218"></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void push<span class="constructor">_front(<span class="params">const</span> <span class="params">value_type</span>&amp;<span class="params">t</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start.cur!=start.frist)&#123;<span class="comment">//第一缓冲区尚有备用空间</span></span><br><span class="line">		construct(start.cur-<span class="number">1</span>,t);<span class="comment">//直接在备用空间上构造元素</span></span><br><span class="line">		--start.cur;<span class="comment">//调整第一缓冲区的使用状态</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="comment">//第一缓冲区已无备用空间</span></span><br><span class="line">		push<span class="constructor">_front_aux(<span class="params">t</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在目前状态下，第一缓冲区并无备用空间，调用push_front_aux()</span></span><br><span class="line"><span class="comment">//只有当第一缓冲区没有任何备用元素时才会调用</span></span><br><span class="line">template&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Alloc,size_t BuffSize&gt;</span><br><span class="line">void deque&lt;T,Alloc,BufSize&gt;::push<span class="constructor">_front_aux(<span class="params">const</span> <span class="params">value_type</span>&amp;<span class="params">t</span>)</span>&#123;</span><br><span class="line">	value_type t_copy=t;</span><br><span class="line">	reserve<span class="constructor">_map_at_front()</span>;<span class="comment">//符合条件，重新更换一个map</span></span><br><span class="line">	*(start.node-<span class="number">1</span>)=allocate<span class="constructor">_node()</span>;<span class="comment">//配置一个新节点(缓冲区)</span></span><br><span class="line">	start.set<span class="constructor">_node(<span class="params">start</span>.<span class="params">node</span>-1)</span>;<span class="comment">//改变start,令其指向新节点</span></span><br><span class="line">	start.cur=start.last-<span class="number">1</span>;<span class="comment">//设定start的状态</span></span><br><span class="line">	construct(start.cur,t_copy);<span class="comment">//针对标的元素设值 </span></span><br><span class="line">	</span><br><span class="line">	start.set<span class="constructor">_node(<span class="params">start_node</span>+1)</span>;</span><br><span class="line">	start.cur=start.first;</span><br><span class="line">	deallocate<span class="constructor">_node(<span class="operator">*</span>(<span class="params">start</span>.<span class="params">node</span>-1)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220922220700986-16638556218581.png" alt="image-20220922220700986"></p>
<p><img src="/posts/800d7d1c/image-20220922220722442-16638556434132.png" alt="image-20220922220722442"></p>
<p>我们判断map什么时候需要重新整治,可以同reserve_map_at_back()和reserve_map_at_front()进行，实际的操作由reallocate_map()进行执行</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void reserve_map_at_back(size_type nodes_to_add=<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nodes_to_add+<span class="number">1</span>&gt;map_size-(finish.node-map))&#123;</span><br><span class="line">		<span class="comment">//如果map尾端的节点备用空间不足</span></span><br><span class="line">		<span class="comment">//符合以上条件则必须重新换一个map(拷贝原来的,配置更大的)</span></span><br><span class="line">		reallocate_map(nodes_to_add,<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void reserve_map_at_front(size_type nodes_to_add=<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nodes_to_add&gt;start.node-map)&#123;</span><br><span class="line">		<span class="comment">//如果map前端的节点备用空间不足</span></span><br><span class="line">		<span class="comment">//符合以上条件则必须要重新换一个map</span></span><br><span class="line">		reallocate_map(nodes_to_add,<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>,<span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;<span class="title">T</span>,<span class="title">Alloc</span>,<span class="title">BUfSize</span>&gt;::<span class="title">reallocate_map</span>(<span class="title">size_type</span> <span class="title">nodes_to_add</span>,<span class="title">bool</span> <span class="title">add_at_front</span>)</span>&#123;</span><br><span class="line">	size_type old_num_nodes=finish.node-start.node+<span class="number">1</span>;<span class="comment">//获得两个迭代器之间的元素数</span></span><br><span class="line">	size_type <span class="keyword">new</span><span class="type">_num_nodes</span>=old_num_nodes+nodes_to_add;</span><br><span class="line">	</span><br><span class="line">	map_pointer <span class="keyword">new</span><span class="type">_nstart</span>;</span><br><span class="line">	<span class="comment">//map_size为中控器之前定义，用于初始化map的大小</span></span><br><span class="line">	<span class="keyword">if</span>(map_size&gt;<span class="number">2</span>*<span class="keyword">new</span><span class="type">_num_nodes</span>)&#123;<span class="comment">//如果之前的map还有多余的大小</span></span><br><span class="line">		<span class="keyword">new</span><span class="type">_nstart</span>=map+(map_size-<span class="keyword">new</span><span class="type">_num_nodes</span>)/<span class="number">2</span>+(add_at_front?notes_to_add:<span class="type">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">new</span><span class="type">_nstart</span>&lt;start.node)</span><br><span class="line">			copy(start.node,finish.node+<span class="number">1</span>,<span class="keyword">new</span><span class="type">_nstart</span>);<span class="comment">//复制内容</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">//逆序复制</span></span><br><span class="line">			copy_backward(start.node,finish.node+<span class="number">1</span>,<span class="keyword">new</span><span class="type">_nstart</span>+old_num_nodes);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		size_type <span class="keyword">new</span><span class="type">_map_size</span>=map_size+max(map_size,nodes_to_add)+<span class="number">2</span>;</span><br><span class="line">		<span class="comment">//配置一块空间，给新map使用</span></span><br><span class="line">		map_pointer <span class="keyword">new</span><span class="type">_map</span>=map_allocator:<span class="type"></span>:allocate(<span class="keyword">new</span><span class="type">_map_size</span>);</span><br><span class="line">		<span class="keyword">new</span><span class="type">_start</span>=<span class="keyword">new</span><span class="type">_map</span>+(<span class="keyword">new</span><span class="type">_map_size</span>-<span class="keyword">new</span><span class="type">_num_nodes</span>)/<span class="number">2</span>+</span><br><span class="line">				  (add_at_front?nodes_to_add:<span class="type">0</span>);</span><br><span class="line">		<span class="comment">//把原map内容拷贝过来</span></span><br><span class="line">		copy(start.node,finish.node+<span class="number">1</span>,<span class="keyword">new</span><span class="type">_nstart</span>);</span><br><span class="line">		<span class="comment">//释放原map</span></span><br><span class="line">		map_allocator:<span class="type"></span>:deallocate(map,map_size);</span><br><span class="line">		<span class="comment">//设定新map的起始地址大小</span></span><br><span class="line">		map=<span class="keyword">new</span><span class="type">_map</span>;</span><br><span class="line">		map_size=<span class="keyword">new</span><span class="type">_map_size</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	start.set_node(<span class="keyword">new</span><span class="type">_nstart</span>);</span><br><span class="line">	finish.set_node(<span class="keyword">new</span><span class="type">_nstart</span>+old_num_nodes<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220922230241676-16638589625903.png" alt="image-20220922230241676"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> pop_back()&#123;</span><br><span class="line">	<span class="keyword">if</span>(finish.cur!=finish.first)&#123;</span><br><span class="line">		<span class="comment">//最后缓冲区有一个(或更多)元素</span></span><br><span class="line">		--frist.cur;</span><br><span class="line">		destroy(finish.cur);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">		<span class="comment">//最后缓冲区没有任何元素</span></span><br><span class="line">		pop_back_aux();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">deque</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span>,<span class="symbol">BufSize</span></span>&gt;::<span class="symbol">pop_back_aux</span>()&#123;</span><br><span class="line">	deallocate_note(finish.first);<span class="comment">//释放最后一个缓冲区</span></span><br><span class="line">	finish.set_node(finish.node<span class="number">-1</span>);<span class="comment">//使之指向上一个缓冲区的最后一个元素</span></span><br><span class="line">	finish.cur=finish.last<span class="number">-1</span>;<span class="comment">//上一个缓冲区的最后一个元素</span></span><br><span class="line">	destory(finish.cur);<span class="comment">//析构该元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> pop_front()&#123;</span><br><span class="line">	<span class="keyword">if</span>(start.cur!=start.last<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="comment">//第一缓冲区还有更多元素</span></span><br><span class="line">		destory(start.cur);</span><br><span class="line">		++start.cur;<span class="comment">//移动指针</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		pop_front_aux();<span class="comment">//第一缓冲区仅有一个元素</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">deque</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span>,<span class="symbol">BufSize</span></span>&gt;::<span class="symbol">pop_front_aux</span>()&#123;</span><br><span class="line">	destroy(start.cur);</span><br><span class="line">	deallocate_node(start.first);<span class="comment">//释放第一缓冲区</span></span><br><span class="line">	start.set_node(start.node+<span class="number">1</span>);<span class="comment">//调整start的状态，使之指向下一缓冲区的第一个元素</span></span><br><span class="line">	start.cur=start.first;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">deque</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span>,<span class="symbol">BufSize</span></span>&gt;::<span class="symbol">clear</span>()&#123;</span><br><span class="line">	<span class="comment">//指针非头尾缓冲区以外的部分，它们的缓冲区元素一定都是满的</span></span><br><span class="line">	<span class="keyword">for</span>(map_pointer node=start.node+<span class="number">1</span>;node&lt;finish.node;++node)&#123;</span><br><span class="line">		<span class="comment">//将缓冲区中所有元素析构 </span></span><br><span class="line">		destroy(*node,*node+buffer_size());</span><br><span class="line">		<span class="comment">//释放缓冲区内存</span></span><br><span class="line">		data_allocator::deallocate(*node,buffer_size());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(start.node!=finish.node)&#123;<span class="comment">//至少有头尾两个缓冲区</span></span><br><span class="line">		destory(start.cur,start.last);<span class="comment">//析构头缓冲区所有元素</span></span><br><span class="line">		destory(finish.cur,finish.last);<span class="comment">//析构尾缓冲区所有元素</span></span><br><span class="line">		<span class="comment">//释放尾部缓冲区,保留头部缓冲区</span></span><br><span class="line">		data_allocator::deallocate(finish.first,buffer_size());</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//头尾在一个缓冲区</span></span><br><span class="line">		destory(start.cur,finish.cur);</span><br><span class="line">	&#125;</span><br><span class="line">	finish=start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除Pos所指的元素,pose为消除点</span></span><br><span class="line">iterator erase(iterator pos)&#123;</span><br><span class="line">	iterator next=pos;</span><br><span class="line">	++next;</span><br><span class="line">	difference_type index=pos-start;<span class="comment">//消除点之前的元素个数 </span></span><br><span class="line">	<span class="keyword">if</span>(index&lt;(size())&gt;&gt;<span class="number">1</span>)&#123; <span class="comment">//如果消除点之前的元素较少，就移动消除点之前的元素size()&gt;&gt;1约等于size()/2</span></span><br><span class="line">	copy_backward(start,pos,next);<span class="comment">//移动元素</span></span><br><span class="line">	pop_front();<span class="comment">//冗余元素</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//消除点之后的元素较少</span></span><br><span class="line">		copy(next,finish,pos);</span><br><span class="line">		pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> start+index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除[first,last)区间内的所有元素</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc,<span class="symbol">size_t</span></span> <span class="symbol">BufSize</span>&gt;</span><br><span class="line"><span class="symbol">deque</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span>,<span class="symbol">Bufsize</span></span>&gt;::<span class="symbol">iterator</span></span><br><span class="line"><span class="symbol">deque</span>&lt;<span class="symbol">T,<span class="symbol">Alloc</span>,<span class="symbol">BufSize</span></span>&gt;::<span class="symbol">earase</span>(<span class="symbol">iterator</span> <span class="symbol">first,<span class="symbol">iterator</span></span> <span class="symbol">last</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(first==start&amp;&amp;last==finish)&#123;<span class="comment">//如果清除区间为整个deque</span></span><br><span class="line">		clear();</span><br><span class="line">		<span class="keyword">return</span> finish;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		difference_type n=last-first;	<span class="comment">//清除区间长度</span></span><br><span class="line">		difference_type elems_before=first-start;<span class="comment">//清除区间前方的元素个数 </span></span><br><span class="line">		<span class="keyword">if</span>(elems_before&lt;(size()-n)/<span class="number">2</span>)&#123; <span class="comment">//如果前方元素较少</span></span><br><span class="line">			copy_backward(start,first,last);<span class="comment">//向后移动前方元素</span></span><br><span class="line">			iterator new_start=start+n;<span class="comment">//标记deque的新起点</span></span><br><span class="line">			destory(start,new_start);<span class="comment">//移动完毕，将冗余的元素析构 </span></span><br><span class="line">			<span class="comment">//以下将冗余的缓冲区释放</span></span><br><span class="line">			<span class="keyword">for</span>(map_pointer cur=start.node;cur&lt;new_start.node;++cur)&#123;</span><br><span class="line">				data_deallocate::deallocate(*cur,buffer_size());</span><br><span class="line">				start=new_start;<span class="comment">//设定deque的新起点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;<span class="comment">//消除区间后方的元素较少</span></span><br><span class="line">			copy(last,finish,first);<span class="comment">//向前移动后方元素</span></span><br><span class="line">			iterator new_finish=finish-n;<span class="comment">//标记deque的新起点</span></span><br><span class="line">			destory(new_finish,fiish);<span class="comment">//将冗余元素析构</span></span><br><span class="line">			<span class="comment">//以下将冗余缓冲区释放</span></span><br><span class="line">			<span class="keyword">for</span>(map_pointer cur=new_finish.node+<span class="number">1</span>;cur&lt;=finish.node;++cur)&#123;</span><br><span class="line">				data_allocator::deallocate(*cur,buffer_size());</span><br><span class="line">			&#125;</span><br><span class="line">			finish=new_finish;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> start+elems_before;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="heap-堆"><a href="#heap-堆" class="headerlink" title="heap(堆)"></a>heap(堆)</h2><p><img src="/posts/800d7d1c/image-20220925153605844-16640913670011.png" alt="image-20220925153605844"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">push_heap</span>(<span class="symbol">RandomAccessIterator</span> <span class="symbol">first,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last</span>)&#123;</span><br><span class="line">	_push_heap_aux(fist,last,distance_type(first),value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator,<span class="symbol">class</span></span> <span class="symbol">Distance,<span class="symbol">class</span></span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_push_heap_aux</span>(<span class="symbol">RandomAccessIterator</span> <span class="symbol">first,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last,<span class="symbol">Distance</span></span>*,<span class="symbol">T</span>*)&#123;</span><br><span class="line">	_push_heap(fist,Distance((last-first)<span class="number">-1</span>),Distance(<span class="number">0</span>),T(*(last<span class="number">-1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator,<span class="symbol">class</span></span> <span class="symbol">Distance,<span class="symbol">class</span></span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">_push_heap</span>(<span class="symbol">RandomAccessIterator</span> <span class="symbol">first,<span class="symbol">Distance</span></span> <span class="symbol">holeIndex,<span class="symbol">Distance</span></span> <span class="symbol">topIndex,<span class="symbol">T</span></span> <span class="symbol">value</span>)&#123;</span><br><span class="line">	Distance parent=(holeIndex<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//找到父节点</span></span><br><span class="line">	<span class="keyword">while</span>(holeIndex&gt;topIndex&amp;&amp;*(first+parent)&lt;value)&#123;</span><br><span class="line">		<span class="comment">//当尚未到达顶端，且父节点小于新值</span></span><br><span class="line">		*(first+holeIndex)=*(first+parent);<span class="comment">//令洞值为父值</span></span><br><span class="line">		holeIndex=parent;<span class="comment">//调整洞号,向上提升至父节点</span></span><br><span class="line">		parent=(holeIndex<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//新的洞的父节点</span></span><br><span class="line">	&#125;<span class="comment">//持续至顶端</span></span><br><span class="line">	*(first+holeIndex)=value;<span class="comment">//令洞值为新值，完成插入操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220925164901821-16640957430692.png" alt="image-20220925164901821"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">pop_heap</span>(<span class="symbol">RandomAccessIteraor</span> <span class="symbol">first,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last</span>)&#123;</span><br><span class="line">	_pop_heap_aux(first,last,value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator,<span class="symbol">class</span></span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_pop_heap_aux</span>(<span class="symbol">RandomAccessIterator</span> <span class="symbol">fist,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last,<span class="symbol">T</span></span>*)&#123;</span><br><span class="line">	_pop_heap(first,last<span class="number">-1</span>,last<span class="number">-1</span>,T(*(last<span class="number">-1</span>)),distance_type(first));</span><br><span class="line">	<span class="comment">//pop操作的结果就为底部容器的第一个元素,因此，首先欲调整值为尾值，然后将首值调至尾节点(所以以上将迭代器Result设为last-1)。然后重整[first,last-1)使之重新成为一个合格的heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;Class RandomAccessIteartor,<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_pop_heap</span>(<span class="symbol">RandomAccessIterator</span> <span class="symbol">first,<span class="symbol">RadomAccessIterator</span></span> <span class="symbol">last,</span></span><br><span class="line"><span class="symbol">					  <span class="symbol">RandomAccessIterator</span></span> <span class="symbol">result,<span class="symbol">T</span></span> <span class="symbol">value,<span class="symbol">Distance</span></span>*)&#123;</span><br><span class="line">	*result=*frist;<span class="comment">//设置尾值为首值 </span></span><br><span class="line">	_adjust_heap(fist,Distance(<span class="number">0</span>),Distance(last-first),value);</span><br><span class="line">	<span class="comment">//以上欲调整heap,洞号为0,欲调整值为value(原尾值)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator,<span class="symbol">class</span></span> <span class="symbol">Distance,<span class="symbol">class</span></span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">_adjust_heap</span>(<span class="symbol">RandomAccessIteartor</span> <span class="symbol">first,<span class="symbol">Distance</span></span> <span class="symbol">holeIndex,<span class="symbol">Distance</span></span> <span class="symbol">len,<span class="symbol">T</span></span> <span class="symbol">value</span>)&#123;</span><br><span class="line">	Distance topIndex=holeIndex;</span><br><span class="line">	Distance secondChild=<span class="number">2</span>*holeIndex+<span class="number">2</span>;<span class="comment">//洞节点之右子节点</span></span><br><span class="line">	<span class="keyword">while</span>(secondChild&lt;len)&#123;</span><br><span class="line">		<span class="comment">//比较洞之节点之左右两个子值，然后以secondChild代表较大的节点</span></span><br><span class="line">		<span class="keyword">if</span>(*(first+secondChild)&lt;*(first+(secondChild<span class="number">-1</span>)))</span><br><span class="line">			secondChild--;</span><br><span class="line">		<span class="comment">//令较大子值为洞值，再令洞号下称至较大子节点处</span></span><br><span class="line">		*(first+holeIndex)=*(first+secondChild);</span><br><span class="line">		holeIndex=secondChild;</span><br><span class="line">		<span class="comment">//找出新洞节点的右子节点</span></span><br><span class="line">		secondChild=<span class="number">2</span>*(secondChild+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(secondChild==len)&#123;<span class="comment">//没有右子节点,只有左子节点</span></span><br><span class="line">		<span class="comment">//令左子值为洞值，再令洞号下移至左子节点处</span></span><br><span class="line">		*(first+holeIndex)=*(first+(secondChild<span class="number">-1</span>));</span><br><span class="line">		holeIndex=secondIndex<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">sort_heap</span>(<span class="symbol">RandomAccessIterator</span> <span class="symbol">first,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last</span>)&#123;</span><br><span class="line">	<span class="comment">//以下，每执行一次pop_heap()，极值即被放在尾端</span></span><br><span class="line">	<span class="comment">//扣除尾端再执行一次pop_heap(),次极值又被放在新尾端,一直下去，最后即得排序结果</span></span><br><span class="line">	<span class="keyword">while</span>(last-first&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		pop_heap(first,last--);<span class="comment">//每执行一次,操作范围即退缩一格</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20220925171710482-16640974317403.png" alt="image-20220925171710482"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">make_heap</span>(<span class="symbol">RandomAccessIterator</span> <span class="symbol">frist,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last</span>)&#123;</span><br><span class="line">	_make_heap(first,last,value_type(first),distance_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator,<span class="symbol">class</span></span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">_make_heap</span>(<span class="symbol">RandomAccessIterator</span> <span class="symbol">first,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last,<span class="symbol">T</span></span>*,<span class="symbol">Distance</span>*)&#123;</span><br><span class="line">	<span class="keyword">if</span>(last-first&lt;<span class="number">2</span>)<span class="keyword">return</span>;<span class="comment">//如果长度为0或1,不必重新排列</span></span><br><span class="line">	<span class="comment">//找出第一个需要重排的子树头部,以parent标示出,由于任何叶节点都不需执行</span></span><br><span class="line">	Distance parent=(len<span class="number">-2</span>)/<span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="comment">//重排以parent为首的子树,len是为了让_adjust_heap()判断操作范围</span></span><br><span class="line">		_adjust_heap(first,parent,len,T(*(first+parent)));</span><br><span class="line">		<span class="keyword">if</span>(parent==<span class="number">0</span>)<span class="keyword">return</span>;<span class="comment">//走完根节点，结束 </span></span><br><span class="line">		parent--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><img src="/posts/800d7d1c/image-20220925173243946-16640983647784.png" alt="image-20220925173243946"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Sequence</span>=<span class="symbol">vector</span>&lt;<span class="symbol">T</span>&gt;,</span><br><span class="line">		<span class="symbol">class</span> <span class="symbol">Compare</span>=<span class="symbol">less</span>&lt;<span class="symbol">typename</span> <span class="symbol">Sequence::<span class="symbol">value_type</span></span>&gt;&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">priority_queue</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> typename Sequence::value_type value_type;</span><br><span class="line">		<span class="keyword">typedef</span> typename Sequence::size_type size_type;</span><br><span class="line">		<span class="keyword">typedef</span> typename Sequence::<span class="built_in">ref</span>erence <span class="built_in">ref</span>erence;</span><br><span class="line">		<span class="keyword">typedef</span> typename Sequence::const_reference const_reference;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		Sequence c;<span class="comment">//底层容器</span></span><br><span class="line">		Compare comp;<span class="comment">//元素大小比较标准</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		priority_queue():c()&#123;&#125;</span><br><span class="line">		<span class="keyword">explicit</span> priority_queue(<span class="keyword">const</span> Compare&amp;x):c(),comp(x)&#123;&#125;</span><br><span class="line">		template&lt;<span class="keyword">class</span> <span class="symbol">InputIterator</span>&gt;</span><br><span class="line">		<span class="symbol">priority_queue</span>(<span class="symbol">InputIterator</span> <span class="symbol">first,<span class="symbol">InputIterator</span></span> <span class="symbol">last,<span class="symbol">const</span></span> <span class="symbol">Compare</span>&amp;<span class="symbol">x</span>)</span><br><span class="line">		:<span class="symbol">c</span>(<span class="symbol">first,<span class="symbol">last</span></span>)&#123;</span><br><span class="line">			make_heap(c.begin(),c.end(),comp);</span><br><span class="line">		&#125;</span><br><span class="line">		priority_queue(InputIterator first,InputIterator last)</span><br><span class="line">		:c(first,last)&#123;</span><br><span class="line">			make_heap(c.begin(),c.end(),comp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">bool</span> empty()<span class="keyword">const</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> c.empty();</span><br><span class="line">		&#125;</span><br><span class="line">		size_type size()<span class="keyword">const</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> c.size();</span><br><span class="line">		&#125;</span><br><span class="line">		const_reference top()<span class="keyword">const</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> c.front();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">void</span> push(<span class="keyword">const</span> value_type&amp;x)&#123;</span><br><span class="line">			c.push_back(x);</span><br><span class="line">			push_heap(c.begin(),c.end(),comp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">void</span> pop()&#123;</span><br><span class="line">			pop_heap(c.begin(),c.end(),comp);</span><br><span class="line">			c.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h2><p>slist为单向链表。</p>
<h3 id="slit的节点"><a href="#slit的节点" class="headerlink" title="slit的节点"></a>slit的节点</h3><p><img src="/posts/800d7d1c/image-20220925175234334-16640995553605.png" alt="image-20220925175234334"></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向链表的节点基本结构 </span></span><br><span class="line">struct _slist_node_base&#123;</span><br><span class="line">	_slist_node_base*next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单向链表的节点结构 </span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">slist_node</span>:<span class="title">public</span> _<span class="title">slist_node_base</span></span>&#123;</span><br><span class="line">	T data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//已知某一节点，插入新节点于其后</span></span><br><span class="line"><span class="keyword">inline</span> _slist_node_base*_slist_make_link(_slist_node_base*prev_node,_slist_node_base*<span class="keyword">new</span><span class="type">_node</span>)&#123;</span><br><span class="line">	<span class="comment">//令new节点的下一节点为prev节点的下一节点</span></span><br><span class="line">	<span class="keyword">new</span><span class="type">_node</span>-&gt;next=prev_node-&gt;next;</span><br><span class="line">	prev_node-&gt;next=<span class="keyword">new</span><span class="type">_node</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span><span class="type">_node</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> size_t _slist_size(_slist_node_base*node)&#123;</span><br><span class="line">	size_t result=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;node!=<span class="number">0</span>;node=node-&gt;next)</span><br><span class="line">		++result;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slist迭代器"><a href="#slist迭代器" class="headerlink" title="slist迭代器"></a>slist迭代器</h3><p><img src="/posts/800d7d1c/image-20220925175758091-16640998789906.png" alt="image-20220925175758091"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向链表的迭代器的基本结构 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_slist_iterator_base</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> forward_iterator_tag iterator_category;<span class="comment">//单向</span></span><br><span class="line">	</span><br><span class="line">	_slist_node_base*node;<span class="comment">//指向节点基本结构 </span></span><br><span class="line">	</span><br><span class="line">	_slist_iterator_base(_slist_node_base*x):<span class="built_in">node</span>(x)&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">incr</span><span class="params">()</span></span>&#123;</span><br><span class="line">		node=node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span>==(<span class="type">const</span> _slist_iterator_base&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> node==x.node;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span>!=(<span class="type">const</span> _slist_iterator_base&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> node!=x.node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单向链表迭代器结构 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_slist_iterator</span>:<span class="keyword">public</span> _slist_iterator_base&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _slist_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> _slist_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*&gt;const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> _slist_iterator&lt;T,Ref,Ptr&gt;self;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	tyepdef _slist_node&lt;T&gt; list_node;</span><br><span class="line">	</span><br><span class="line">	_slist_iterator(list_node*x):_list_iterator_base(x)&#123;&#125;</span><br><span class="line">	_slist_iterator():_slist_iterator_base(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	_slist_iterator(<span class="type">const</span> iterator:x):_slist_iterator_base(x.node)&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	reference <span class="keyword">operator</span>*()<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((list_node*)node)-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;()<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	self&amp;<span class="keyword">operator</span>++()&#123;</span><br><span class="line">		<span class="built_in">incr</span>();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">		self temp=*<span class="keyword">this</span>;</span><br><span class="line">		<span class="built_in">incr</span>();</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slist的数据结构"><a href="#slist的数据结构" class="headerlink" title="slist的数据结构"></a>slist的数据结构</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> slist&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T value_type;</span><br><span class="line">		<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">		<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">typedef</span> _slist_iterator&lt;T,T&amp;,T*&gt; interator;</span><br><span class="line">		<span class="keyword">typedef</span> _slist_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*&gt;const_iterator;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">typedef</span> _slist_node&lt;T&gt; list_node;</span><br><span class="line">		<span class="keyword">typedef</span> _slist_node_base list_node_base;</span><br><span class="line">		<span class="keyword">typedef</span> _slist_iterator_base iterator_base;</span><br><span class="line">		<span class="keyword">typedef</span> simple_alloc&lt;list_node,Alloc&gt;list_node_allocator;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">static</span> list_node*<span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp;x)</span></span>&#123;</span><br><span class="line">			list_node*node=list_node_allocator::<span class="built_in">allocate</span>();<span class="comment">//配置空间</span></span><br><span class="line">			<span class="built_in">construct</span>(&amp;node-&gt;data,x);<span class="comment">//构造元素</span></span><br><span class="line">			node-&gt;next=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy_node</span><span class="params">(list_node*node)</span></span>&#123;</span><br><span class="line">			<span class="built_in">destory</span>(&amp;node-&gt;data);</span><br><span class="line">			list_node_allocator::<span class="built_in">deallocate</span>(node);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		list_node_base head; <span class="comment">//头部</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">slist</span>()&#123;head.next=<span class="number">0</span>;&#125;</span><br><span class="line">    	~<span class="built_in">slist</span>()&#123;<span class="built_in">clear</span>();&#125;</span><br><span class="line">    	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">iterator</span>((list_node*)head.next);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _slist_size(head.size);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> head.next=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//两个slist互换，只需要将head交换即可</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(slist&amp;L)</span></span>&#123;</span><br><span class="line">			list_node_base*temp=head.next;</span><br><span class="line">			head.next=L.head.next;</span><br><span class="line">			L.head.next=temp;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//取头部元素</span></span><br><span class="line">		<span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> ((list_node*)head.next)-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//从头部插入元素</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp;x)</span></span>&#123;</span><br><span class="line">			_slist_make_link(&amp;head,<span class="built_in">create_node</span>(x));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//从头部取走元素(删除)</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;</span><br><span class="line">			list_node*node=(list_node*)head.next;</span><br><span class="line">			head.next=node-&gt;next;</span><br><span class="line">			<span class="built_in">destroy_node</span>(node);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>普通二叉树与平衡二叉树的区别是，当一些随机输入值插入树中时，普通二叉树会出现极度不平衡的情况，该情况会导致插入、查找 、删除相较于平衡二叉树有较差的效率。而平衡二叉树可以自动调整，使得整个树保持在一个平衡的状态。</p>
<p><img src="/posts/800d7d1c/image-20220928223207195-16643755283061.png" alt="image-20220928223207195"></p>
<h3 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h3><p>AVL tree是一个”加上额外平衡条件”的二查搜索树。其平衡条件的建立是为了确保整棵树的深度为O(logN)。</p>
<p><img src="/posts/800d7d1c/image-20220928223948012-16643759894172.png" alt="image-20220928223948012"></p>
<p>在插入了节点11之后，灰色节点违反了AVL tree 的平衡条件.只有插入点至根节点路径上的各节点有可能改变平衡状态。因此，只需要调整其中最深的那个节点，便可使得整棵树重新获得平衡。</p>
<p>假设最深节点为X，由于节点最多拥有有两个子节点，而所谓”平衡被破坏”意味着X的左右两棵子树的高度为相相差为2，因此我们可以将情况分为以下四种情况。</p>
<ol>
<li>插入点位于X的左子节点的左子树——左左</li>
<li>插入点位于X的左子节点的右子树——左右</li>
<li>插入点位于X的右子节点的左子树——右左</li>
<li>插入点位于X的右子节点的右子树——右右</li>
</ol>
<p>情况1,4彼此对称 ，称为外侧插入。采用单侧旋转来调整。而情况2,3彼此对称 ，称为内侧插入，采用双旋转操作来调整。</p>
<p><img src="/posts/800d7d1c/image-20220928224731335-16643764524403.png" alt="image-20220928224731335"></p>
<h4 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h4><p><img src="/posts/800d7d1c/image-20220928224912559-16643765535584.png" alt="image-20220928224912559"></p>
<p>我们把键值11插入后，导致左右两边深度不平衡。在18的左边深度为3，而右边的深度为1。故我们需要对该树进行旋转操作。</p>
<h4 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h4><p><img src="/posts/800d7d1c/image-20221002181559205-16647057603301.png" alt="image-20221002181559205"></p>
<p>双旋转主要是修正因内侧插入而导致的不平衡。</p>
<p><img src="/posts/800d7d1c/image-20221002182152029-16647061129322.png" alt="image-20221002182152029"></p>
<h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><p>为了保证查找树的平衡性，我们需要允许在树中的一个结点保存多个键。</p>
<p><strong>定义：</strong>一棵2-3查找树或为一棵空树，由以下结点组成。 2-结点，含有一个键(及其对应的值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。3-结点，含有两个键(及其对应的值)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间。右链接指向的2-3树中的键都大于该结点。</p>
<p><img src="/posts/800d7d1c/image-20221002184127147-16647072879763.png" alt="image-20221002184127147"></p>
<p>一棵完美平衡的2-3查找树中的所有空链接到根结点的距离应该都相同。</p>
<p>将二叉查找树的查找算法一般化我们能直接得到2-3树的查找算法。要判断一个键是否存在树中。我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中。否则，我们根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。</p>
<p><img src="/posts/800d7d1c/image-20221002185532144-16647081330824.png" alt="image-20221002185532144"></p>
<p>向2-结点中插入新键</p>
<p><img src="/posts/800d7d1c/image-20221002185840119-16647083208805.png" alt="image-20221002185840119"></p>
<p>向一棵只含有一个3-结点的树中插入新键</p>
<p><img src="/posts/800d7d1c/image-20221002185924690-16647083658136.png" alt="image-20221002185924690"></p>
<p><img src="/posts/800d7d1c/image-20221002190243377-16647085644087.png" alt="image-20221002190243377"></p>
<h4 id="2-3树的变化过程"><a href="#2-3树的变化过程" class="headerlink" title="2-3树的变化过程"></a>2-3树的变化过程</h4><p><img src="/posts/800d7d1c/image-20221002190947746-16647089888968.png" alt="image-20221002190947746"></p>
<h4 id="2-3树的构造过程"><a href="#2-3树的构造过程" class="headerlink" title="2-3树的构造过程"></a>2-3树的构造过程</h4><p><img src="/posts/800d7d1c/image-20221002191030021-16647090313319.png" alt="image-20221002191030021"></p>
<h4 id="2-3查找树的删除过程"><a href="#2-3查找树的删除过程" class="headerlink" title="2-3查找树的删除过程"></a>2-3查找树的删除过程</h4><p>2-3查找树的删除与AVL tree删除过程差不多，只不过比AVL tree的情况更多而已。我们有如果策略，我们可以在被删除的节点处，找到左侧的最大值，或右侧的最小值用以顶替被删除的值。如</p>
<p><img src="/posts/800d7d1c/image-20221002195302553-166471158328512.png" alt="image-20221002195302553"></p>
<p>假设我们要删除节点C，则有</p>
<p><img src="/posts/800d7d1c/image-20221003131949318-16647743908361.png" alt="image-20221003131949318"></p>
<p>在删除C后，我们可以从左子树中寻找最大节点或从右子树中寻找最小节点来替代节点C。即我们有节点树</p>
<p><img src="/posts/800d7d1c/image-20221003132703768-16647748248992.png" alt="image-20221003132703768"></p>
<p><img src="/posts/800d7d1c/image-20221003133056578-16647750577543.png" alt="image-20221003133056578"></p>
<p><img src="/posts/800d7d1c/image-20221003134745313-16647760663344.png" alt="image-20221003134745313"></p>
<p><img src="/posts/800d7d1c/image-20221003135231952-16647763534515.png" alt="image-20221003135231952"></p>
<h3 id="红黑二叉查找树"><a href="#红黑二叉查找树" class="headerlink" title="红黑二叉查找树"></a>红黑二叉查找树</h3><p><strong>红黑二叉查找树其本质是用额外的信息来表示2-3树。即用标准二叉树(完全由2-结构构成)和一些额外的信息(替换3-结点)来表示2-3树。</strong>我们将树中的链接分为两种类型:<strong>红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中普通链接。</strong>即我们将3-结点表示为由一条左斜的红色链接(两个2-结点其中之一是另一个左子结点)相连的两个结点。</p>
<p><img src="/posts/800d7d1c/image-20221002192302522-166470978413810.png" alt="image-20221002192302522"></p>
<h4 id="红黑树的另一种定义"><a href="#红黑树的另一种定义" class="headerlink" title="红黑树的另一种定义"></a>红黑树的另一种定义</h4><p>红黑树的另一种定义是含有红黑链接并满足以下条件的二叉查找树：</p>
<ul>
<li>红链接均为左链接</li>
<li>没有任何一个结点同时和两条红链接相连</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径数量相同</li>
</ul>
<p><img src="/posts/800d7d1c/image-20221002192641135-166471000233611.png" alt="image-20221002192641135"></p>
<h4 id="颜色表示"><a href="#颜色表示" class="headerlink" title="颜色表示"></a>颜色表示</h4><p>每个结点都只会有一条指向自己链接(从它的父结点指向它)，我们将链接的颜色保存在给结点的Node数据类型的布尔变量中。如果指向它的链接是红色的，那么该变量为true，黑色为false。则我们有结构定义</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line"> Key key;<span class="regexp">//</span>键</span><br><span class="line"> Value val;<span class="regexp">//</span>相关联的值</span><br><span class="line"> Node Left,Right;<span class="regexp">//</span>左右子树</span><br><span class="line"> int N;<span class="regexp">//</span>这棵树的总结点数</span><br><span class="line"> boolean color;<span class="regexp">//</span>其父结点指向它链接的颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20221003140855674-16647773367916.png" alt="image-20221003140855674"></p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>我们在实现某些操作中可能会出现<strong>红色右链接</strong>或都<strong>两条连续的红色链接</strong>，但在操作完成前这些情况都会被小心地旋转并修复。旋转操作会改变红链接的指向。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//左旋转</span><br><span class="line"><span class="keyword">Node</span> <span class="title">rotateLeft</span>(<span class="keyword">Node</span> <span class="title">h</span>)&#123;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">x</span>=h.right;//保存右子节点</span><br><span class="line">	h.<span class="attr">right=</span>x.left;</span><br><span class="line">	x.<span class="attr">left=</span>h;</span><br><span class="line">	x.<span class="attr">color=</span>h.color;</span><br><span class="line">	h.<span class="attr">color=</span>RED;</span><br><span class="line">	x.N=h.N;</span><br><span class="line">	h.N=<span class="number">1</span>+size(h.left)+size(h.right);</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line">//右旋转</span><br><span class="line"><span class="keyword">Node</span> <span class="title">rotateRight</span>(<span class="keyword">Node</span> <span class="title">h</span>)&#123;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">x</span>=h.left;</span><br><span class="line">	h.<span class="attr">left=</span>x.right;</span><br><span class="line">	x.<span class="attr">right=</span>h;</span><br><span class="line">	x.<span class="attr">color=</span>h.color;</span><br><span class="line">	h.<span class="attr">color=</span>RED;</span><br><span class="line">	x.N=h.N;</span><br><span class="line">	h.N=<span class="number">1</span>+size(h.left)+size(h.right);</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20221003142618496-16647783793657.png" alt="image-20221003142618496"></p>
<h4 id="向树底部的2-结点插入新建"><a href="#向树底部的2-结点插入新建" class="headerlink" title="向树底部的2-结点插入新建"></a>向树底部的2-结点插入新建</h4><p><img src="/posts/800d7d1c/image-20221003143015154-16647786160468.png" alt="image-20221003143015154"></p>
<h4 id="向一棵双键树-即一个3-结点-中插入新键"><a href="#向一棵双键树-即一个3-结点-中插入新键" class="headerlink" title="向一棵双键树(即一个3-结点)中插入新键"></a>向一棵双键树(即一个3-结点)中插入新键</h4><p>可分为三种子情况：新建小于树中的两个键，在两者之间，或是大于树中的两个键。每种情况都会产生一个同时连接到两条红链接的结点，我们的目标就是修正这一点。</p>
<ul>
<li>当新键大于原树中的两个键，因此会被连接到3-结点的左路链接。此时树是平衡的，根结点为中间大小的键。它有两条红链接分别和较小和较大的结点相连。如果我们将两条链接的颜色都由红变黑，那么我们会得到一棵由三个结点组成，高为2的平衡树。见下图。</li>
<li>如果新键小于原树中的两个键，它会被链接到最左边的空链接，会产生两条连续的红链接，此时我们只需要将上层的红链接右旋转即可得到第一种情况。</li>
<li>如果新键介于原树中的两个键之间，这又会产生两条连续的红链接，一条红色左链接接一条红色右链接，只需要将下层的红链接左旋转即可得到第二种情况。</li>
</ul>
<p><img src="/posts/800d7d1c/image-20221003144229126-16647793503319.png" alt="image-20221003144229126"></p>
<h4 id="颜色转换"><a href="#颜色转换" class="headerlink" title="颜色转换"></a>颜色转换</h4><p>我们使用一个方法filpColors()来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑之外，还需要将父结点的颜色由黑变红。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void filpColors(Node h)&#123;</span><br><span class="line">	h.color<span class="operator">=</span>RED<span class="comment">;</span></span><br><span class="line">	h.left.color<span class="operator">=</span>BLACK<span class="comment">;</span></span><br><span class="line">	h.right.color<span class="operator">=</span>BLACK<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：根结点总是黑色的</strong></p>
<p><img src="/posts/800d7d1c/image-20221003145356460-166478003735310.png" alt="image-20221003145356460"></p>
<h4 id="向树底部的3-结点插入新键"><a href="#向树底部的3-结点插入新键" class="headerlink" title="向树底部的3-结点插入新键"></a>向树底部的3-结点插入新键</h4><p><img src="/posts/800d7d1c/image-20221003150235184-166478055622012.png" alt="image-20221003150235184"></p>
<p>在沿着插入点到根结点的路径向上移动时在所经过每个结点中顺序完成以下操作，我们能完成插入操作。</p>
<ul>
<li>如果右子结点是红色的而左子结点是黑色的，进行左旋转。</li>
<li>如果左子结点是红色的且它的左子结点也是红色的，进行右旋转。</li>
<li>如果左右子结点均为红色，进行颜色转换。</li>
</ul>
<p><img src="/posts/800d7d1c/image-20221003150514433-166478071532513.png" alt="image-20221003150514433"></p>
<h4 id="插入实现"><a href="#插入实现" class="headerlink" title="插入实现"></a>插入实现</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> RedBlackBST&lt;Key extends Comparable&lt;Key&gt;,Value&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> Node root;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> Node;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> boolean is<span class="constructor">Red(Node <span class="params">h</span>)</span>;</span><br><span class="line">	<span class="keyword">private</span> Node rotate<span class="constructor">Left(Node <span class="params">h</span>)</span>;</span><br><span class="line">	<span class="keyword">private</span> Node rotate<span class="constructor">Right(Node <span class="params">h</span>)</span>;</span><br><span class="line">	<span class="keyword">private</span> void filp<span class="constructor">Colors(Node <span class="params">h</span>)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> size<span class="literal">()</span>;</span><br><span class="line">	</span><br><span class="line">	public void put(Key key,Value <span class="keyword">val</span>)&#123;</span><br><span class="line">		<span class="comment">//查找key,找到则更新其值，否则为它新建一个结点 </span></span><br><span class="line">		root=put(root,key,<span class="keyword">val</span>);</span><br><span class="line">		root.color=Black;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Node put(Node h,Key key,Value <span class="keyword">val</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(h==null)&#123; <span class="comment">//新建结点,父节点用红链接相连</span></span><br><span class="line">			return <span class="keyword">new</span> <span class="constructor">Node(<span class="params">key</span>,<span class="params">val</span>,1,RED)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">int</span> cmp=key.compare<span class="constructor">To(<span class="params">h</span>.<span class="params">key</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">			h.left=put(h.left,key,<span class="keyword">val</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">			h.right=put(h.right,key,<span class="keyword">val</span>);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			h.<span class="keyword">val</span>=<span class="keyword">val</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>)<span class="comment">//右节点为红链接</span></span><br><span class="line">			h=rotate<span class="constructor">Left(<span class="params">h</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>&amp;&amp;is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>.<span class="params">left</span>)</span>)&#123;<span class="comment">//左节点与左节点的左节点都为红链接</span></span><br><span class="line">			h=rotate<span class="constructor">Right(<span class="params">h</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>&amp;&amp;is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>)</span>)</span><br><span class="line">			flip<span class="constructor">Colors(<span class="params">h</span>)</span>;</span><br><span class="line">		h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">		return h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20221003152248525-166478176963214.png" alt="image-20221003152248525"></p>
<h4 id="自顶向下的2-3-4树"><a href="#自顶向下的2-3-4树" class="headerlink" title="自顶向下的2-3-4树"></a>自顶向下的2-3-4树</h4><p>2-3-4树的插入算法，2-3-4树中允许存在我们以前见过的4-结点。它的插入算法沿查找路径向下进行变换是为了保证当前结点不是4-结点(这样树底才有空间来插入新的键)，沿查找路径向上进行变换是为了将之前创建的4-结点配平。</p>
<ul>
<li>如果根结点是4-结点，则将它分解成三个2-结点，使得树高加1。</li>
<li>在向下查找的过程中，如果遇到一个父结点为2-结点的4-结点，将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点变成一个3-结点。</li>
<li>在向下查找的过程中，如果遇到一个父结点为3-结点的4-结点，我们将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点变成一个4-结点。</li>
</ul>
<p><strong>注：该算法在查找要删除的值的过程进行变换，使得只保留2-和3-结点，并且要删除的值必在一棵2-结点中(不包括父结点)，这样做可以删除值之后能较好进行插入。</strong></p>
<p><img src="/posts/800d7d1c/image-20221003155011678-166478341256315.png" alt="image-20221003155011678"></p>
<p>在实现这个算法，我们需要</p>
<ul>
<li>将4-结点表示为由三个2-结点组成的一棵平衡的子树，根结点和两个子结点都用红链接相连</li>
<li>在向下的过程中分解所有4-结点并进行颜色转换</li>
<li>和插入操作一样，在向上的过程中用旋转将4-结点进行配平</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现</span></span><br><span class="line">public void put(Key key,Value <span class="keyword">val</span>)&#123;</span><br><span class="line">		<span class="comment">//查找key,找到则更新其值，否则为它新建一个结点 </span></span><br><span class="line">		root=put(root,key,<span class="keyword">val</span>);</span><br><span class="line">		root.color=Black;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Node put(Node h,Key key,Value <span class="keyword">val</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(h==null)&#123; <span class="comment">//新建结点,父节点用红链接相连</span></span><br><span class="line">			return <span class="keyword">new</span> <span class="constructor">Node(<span class="params">key</span>,<span class="params">val</span>,1,RED)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>&amp;&amp;is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>)</span>)</span><br><span class="line">			flip<span class="constructor">Colors(<span class="params">h</span>)</span>;</span><br><span class="line">		<span class="built_in">int</span> cmp=key.compare<span class="constructor">To(<span class="params">h</span>.<span class="params">key</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">			h.left=put(h.left,key,<span class="keyword">val</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">			h.right=put(h.right,key,<span class="keyword">val</span>);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			h.<span class="keyword">val</span>=<span class="keyword">val</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>)<span class="comment">//右节点为红链接</span></span><br><span class="line">			h=rotate<span class="constructor">Left(<span class="params">h</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>&amp;&amp;is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>.<span class="params">left</span>)</span>)&#123;<span class="comment">//左节点与左节点的左节点都为红链接</span></span><br><span class="line">			h=rotate<span class="constructor">Right(<span class="params">h</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">		return h;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除最小键"><a href="#删除最小键" class="headerlink" title="删除最小键"></a>删除最小键</h4><p>我们注意到从树底部的3-结点中删除键是很简单的，但是2-结点则不然。从2-结点中删除一个键会留下一个空结点，一般我们会将它替换成一个空链接，我们沿着左链接如下进行变换，确保当前结点不是2-结点(可能是3-结点，也可能是4-结点)。</p>
<p>首先根结点可能有两种情况(见下图)。</p>
<ul>
<li>如果根是2-结点且它的两个子结点都是2-结点，我们可以直接将这三个结点变成一个4-结点。</li>
<li>如果根为2-结点且左子结点是2-结点，但右子结点不2-结点，则我们需要从右子结点中借一个结点过来。</li>
</ul>
<p>在沿着左链接如下的过程中，需要保证以下情况之一成立(见下图)。</p>
<ul>
<li>如果当前结点的左子结点不是2-结点，完成。</li>
<li>如果当前结点的左子结点是2-结点而它亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移动到左子结点中。</li>
<li>如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个4-结点，使父结点由3-结点变为2-结点或由4-结点变为3-结点</li>
</ul>
<p><img src="/posts/800d7d1c/image-20221003173237428-166478955836716.png" alt="image-20221003173237428"></p>
<p>在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3-结点或4-结点，然后我们可以直接从中将其删除，将3-结点变为2-结点，或者将4-结点变为3-结点，然后再回头向上分解所有临时的4-结点。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node move<span class="constructor">RedLeft(Node <span class="params">h</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//假设结点h为红色,h.left和h.left.left都是黑色</span></span><br><span class="line">	<span class="comment">//将h.left或h.left的子结点之一变红</span></span><br><span class="line">	flip<span class="constructor">Colors(<span class="params">h</span>)</span>;<span class="comment">//如果结点h为红色则将父结点设为黑，两节点设为红，即合并成一个4-结点</span></span><br><span class="line">	<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>.<span class="params">left</span>)</span>)&#123;<span class="comment">//即从右子节点中借一个节点过来</span></span><br><span class="line">		h.right=rotate<span class="constructor">Right(<span class="params">h</span>.<span class="params">right</span>)</span>;<span class="comment">//从右旋转</span></span><br><span class="line">		h=rotate<span class="constructor">Left(<span class="params">h</span>)</span>;<span class="comment">//左旋转</span></span><br><span class="line">	&#125;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">public void delete<span class="constructor">Min()</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Red(<span class="params">root</span>.<span class="params">left</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">root</span>.<span class="params">right</span>)</span>)&#123;<span class="comment">//左右节点皆为2-结点，合并为4-结点</span></span><br><span class="line">		root.color=RED;</span><br><span class="line">	&#125;</span><br><span class="line">	root=delete<span class="constructor">Min(<span class="params">root</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Empty()</span>)</span><br><span class="line">		root.color=BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node delete<span class="constructor">Min(Node <span class="params">h</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(h.left==null)</span><br><span class="line">		return null;</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>.<span class="params">left</span>)</span>)&#123;</span><br><span class="line">		h=move<span class="constructor">RedLeft(<span class="params">h</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	h.left=delete<span class="constructor">Min(<span class="params">h</span>.<span class="params">left</span>)</span>;</span><br><span class="line">	return balance(h);<span class="comment">//向上进行合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node balance(Node h)&#123;</span><br><span class="line">	<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>)</span>)</span><br><span class="line">		h=rotate<span class="constructor">Left(<span class="params">h</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>)<span class="comment">//右节点为红链接</span></span><br><span class="line">		h=rotate<span class="constructor">Left(<span class="params">h</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>&amp;&amp;is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>.<span class="params">left</span>)</span>)&#123;<span class="comment">//左节点与左节点的左节点都为红链接</span></span><br><span class="line">		h=rotate<span class="constructor">Right(<span class="params">h</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>&amp;&amp;is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>)</span>)</span><br><span class="line">		flip<span class="constructor">Colors(<span class="params">h</span>)</span>;</span><br><span class="line">	h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除最大键"><a href="#删除最大键" class="headerlink" title="删除最大键"></a>删除最大键</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node move<span class="constructor">RedRight(Node <span class="params">h</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//假设结点h为红色,h.right和h.right.left都是黑色</span></span><br><span class="line">	<span class="comment">//将h.right或h.right的子结点之一变红</span></span><br><span class="line">	filp<span class="constructor">Colors(<span class="params">h</span>)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>.<span class="params">left</span>)</span>)&#123;</span><br><span class="line">		h=rotate<span class="constructor">Right(<span class="params">h</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">public void delete<span class="constructor">Max()</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Red(<span class="params">root</span>.<span class="params">left</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">root</span>.<span class="params">right</span>)</span>)&#123;</span><br><span class="line">		root.color=RED;</span><br><span class="line">	&#125;</span><br><span class="line">	root=delete<span class="constructor">Max(<span class="params">root</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Empty()</span>)</span><br><span class="line">		root.color=BLACK;</span><br><span class="line">&#125;</span><br><span class="line">public Node delete<span class="constructor">Max()</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Red(<span class="params">root</span>.<span class="params">left</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">root</span>.<span class="params">right</span>)</span>)</span><br><span class="line">		root.color=RED;</span><br><span class="line">	root=delete<span class="constructor">Max(<span class="params">root</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Empty()</span>)</span><br><span class="line">		root.color=BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node delete<span class="constructor">Max(Node <span class="params">h</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>)</span><br><span class="line">		h=rotate<span class="constructor">Right(<span class="params">h</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span>(h.right==null)</span><br><span class="line">		return null;</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>.<span class="params">left</span>)</span>)</span><br><span class="line">		h=move<span class="constructor">RedRight(<span class="params">h</span>)</span>;</span><br><span class="line">	h.right=delete<span class="constructor">Max(<span class="params">h</span>.<span class="params">right</span>)</span>;</span><br><span class="line">	return blance(h);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void delete(Key key)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Red(<span class="params">root</span>.<span class="params">left</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">root</span>.<span class="params">right</span>)</span>)</span><br><span class="line">		root.color=RED;</span><br><span class="line">	root=delete(root,key);</span><br><span class="line">	<span class="keyword">if</span>(!is<span class="constructor">Empty()</span>)</span><br><span class="line">		root.color=BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node delete(Node h,Key key)&#123;</span><br><span class="line">	<span class="keyword">if</span>(key.compare<span class="constructor">To(<span class="params">h</span>.<span class="params">key</span>)</span>&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>.<span class="params">left</span>)</span>)</span><br><span class="line">			h=move<span class="constructor">RedLeft(<span class="params">h</span>)</span>;</span><br><span class="line">		h.left=delete(h.left.key);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(is<span class="constructor">Red(<span class="params">h</span>.<span class="params">left</span>)</span>)</span><br><span class="line">			h=rotate<span class="constructor">Right(<span class="params">h</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span>(key.compare<span class="constructor">To(<span class="params">h</span>.<span class="params">key</span>)</span>==<span class="number">0</span>&amp;&amp;(h.right==null))&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>)</span>&amp;&amp;!is<span class="constructor">Red(<span class="params">h</span>.<span class="params">right</span>.<span class="params">left</span>)</span>)&#123;</span><br><span class="line">			h=move<span class="constructor">RedRight(<span class="params">h</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(key.compare<span class="constructor">To(<span class="params">h</span>.<span class="params">key</span>)</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			h.<span class="keyword">val</span>=get(h.right,min(h.right).key);</span><br><span class="line">			h.key=min(h.right).key;</span><br><span class="line">			h.right=delete<span class="constructor">Min(<span class="params">h</span>.<span class="params">right</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			h.right=delete(h.right,key);</span><br><span class="line">	&#125;</span><br><span class="line">	return balance(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RB-Tree的节点设计"><a href="#RB-Tree的节点设计" class="headerlink" title="RB-Tree的节点设计"></a>RB-Tree的节点设计</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> _rb_tree_color_type;</span><br><span class="line"><span class="keyword">typedef</span> _rb_tree_color_type _rb_tree_red=<span class="literal">false</span>;<span class="comment">//红色为0</span></span><br><span class="line"><span class="keyword">typedef</span> _rb_tree_color_type _rb_tree_black=<span class="literal">true</span>;<span class="comment">//黑色为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_node_base</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_color_type color_type;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node_base* base_ptr;</span><br><span class="line">	</span><br><span class="line">	color_type color;<span class="comment">//节点颜色,非红即黑</span></span><br><span class="line">	base_ptr parent;<span class="comment">//RB树的许多操作,必须知道父节点</span></span><br><span class="line">	base_ptr left;<span class="comment">//指向左节点</span></span><br><span class="line">	base_ptr right;<span class="comment">//指向右节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(x-&gt;left!=<span class="number">0</span>) x=x-&gt;left; <span class="comment">//一直向左走，就会找到最小值</span></span><br><span class="line">		<span class="keyword">return</span> x; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(x-&gt;right!=<span class="number">0</span>) x=x-&gt;right;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_node</span>:<span class="keyword">public</span> _rb_tree_node_base&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	Value value_field;<span class="comment">//节点值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20221004161812403-16648714932681.png" alt="image-20221004161812403"></p>
<p><img src="/posts/800d7d1c/image-20221004162148787-16648717104122.png" alt="image-20221004162148787"></p>
<h4 id="RB-tree的数据结构"><a href="#RB-tree的数据结构" class="headerlink" title="RB-tree的数据结构"></a>RB-tree的数据结构</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">Key,<span class="symbol">class</span></span> <span class="symbol">Value,<span class="symbol">class</span></span> <span class="symbol">KeyOfValue,<span class="symbol">class</span></span> <span class="symbol">Compare,<span class="symbol">class</span></span> <span class="symbol">Alloc</span>=<span class="symbol">alloc</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">rb_tree</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	size_type node_count;<span class="comment">//追踪记录树的大小(即节点数量)</span></span><br><span class="line">    link_type header;</span><br><span class="line">    Compare key_compare;<span class="comment">//节点的键值大小比较准则</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node,Alloc&gt; rb_tree_node_allocator;</span><br><span class="line">	link_type get_node()&#123; <span class="keyword">return</span> rb_tree_node_allocator::allocate();&#125;</span><br><span class="line">	<span class="built_in">void</span> init()&#123;</span><br><span class="line">		header=get_node();<span class="comment">//产生一个节点空间,使header指向它</span></span><br><span class="line">		color(header)=_rb_tree_red;<span class="comment">//令header为红色</span></span><br><span class="line">		root()=<span class="number">0</span>;</span><br><span class="line">		leftMost()=header;<span class="comment">//令左子节点为自已</span></span><br><span class="line">		rightMost()=header;<span class="comment">//令右子节点为自己</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的特性是所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有有实值(value)和键值(key)。set元素的键值就是实值，实值就是键值，set不允许两个元素有相同的键值。</p>
<p>我们无法通过set的迭代器去改变set的元素。因为set<T>::iterator 被 定义为底层RB-tree的const_iterator。</T></p>
<p>由于RB-tree是一种平衡二叉树，自动排序效果很不错，所以标准的STL set即以RB-Tree的为底层机制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>=less&lt;Key&gt;,<span class="keyword">class</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> set&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">		<span class="keyword">typedef</span> Key value_type;</span><br><span class="line">		<span class="comment">//以下key_compare和value_compare使用同一比较函数</span></span><br><span class="line">		<span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">		<span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">			struct identity:public unary_function&lt;T,T&gt;&#123;</span></span><br><span class="line"><span class="comment">				const T&amp; operator()(const T&amp;x)const&#123;</span></span><br><span class="line"><span class="comment">					return x;</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,identity&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">		rep_type t;<span class="comment">//采用红黑树来表现set</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iteraotr iterator;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">set</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp;comp)</span>:t(comp)&#123;</span>&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">		<span class="title">set</span><span class="params">(InputIterator first,InputIterator last)</span>:t(Compare())&#123;</span></span><br><span class="line">			t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">		<span class="title">set</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp;comp)</span>:t(comp)&#123;</span></span><br><span class="line">			t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		set&lt;<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x&gt;:<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">		set&lt;Key,Compare,Alloc&gt;&amp;<span class="keyword">operator</span>=(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">			t=x.t;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span> </span>&#123;retur t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">		<span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">		<span class="function">iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">		<span class="function">iterator <span class="title">end</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">		<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">		<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">		<span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">		<span class="function">size_type <span class="title">max_size</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(set&lt;Key,Compare,Alloc&gt;&amp;x)</span> </span>&#123;t.<span class="built_in">swap</span>(x.t); &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">typedef</span> pair&lt;iterator,<span class="type">bool</span>&gt;pair_iterator_bool;</span><br><span class="line">		<span class="function">pair_iterator_bool <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp;x)</span></span>&#123;</span><br><span class="line">			pair&lt;<span class="keyword">typename</span> rep_type::iterator,<span class="type">bool</span>&gt;p=t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(p.first,p.second);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> x.<span class="built_in">erase</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span><span class="type">const</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> t.<span class="built_in">count</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set底层运用rb-tree进行数据的插入、删除和查找 。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的特性是,所有元素都会根据元素的键值自动被排序。map的所有元素都是pair，同时拥有实值和键值,pair的第一元素被视为键值，第二元素被视为实值。Map不允许两个元素拥有相同的键值。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pair定义</span></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">struct pair&#123;</span><br><span class="line">	typedef T1 first_type;</span><br><span class="line">	typedef T2 second_type;</span><br><span class="line">	</span><br><span class="line">	T1 first;</span><br><span class="line">	T2 second;</span><br><span class="line">	<span class="built_in">piar</span>()<span class="selector-pseudo">:first</span>(T1()),<span class="built_in">second</span>(T2())&#123;&#125;</span><br><span class="line">	<span class="built_in">pair</span>(const T1&amp;a,const T2&amp;b)<span class="selector-pseudo">:first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20221004173222962-16648759440243.png" alt="image-20221004173222962"></p>
<p><img src="/posts/800d7d1c/image-20221004173404834-16648760463374.png" alt="image-20221004173404834"></p>
<h2 id="multiSet"><a href="#multiSet" class="headerlink" title="multiSet"></a>multiSet</h2><p><img src="/posts/800d7d1c/image-20221004173639998-16648762013695.png" alt="image-20221004173639998"></p>
<h2 id="multiMap"><a href="#multiMap" class="headerlink" title="multiMap"></a>multiMap</h2><p><img src="/posts/800d7d1c/image-20221004173718338-16648762397866.png" alt="image-20221004173718338"></p>
<h2 id="hashtable-哈希表"><a href="#hashtable-哈希表" class="headerlink" title="hashtable(哈希表)"></a>hashtable(哈希表)</h2><p>hash table可提供对任何有名项的存取操作和删除操作。由于操作对象是有名项，所以hash table也可被视为一个字典结构，这种结构的用意在于提供常数时间之基本操作。</p>
<h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><p>负载系数 ，指元素个数除以表格大小。负载系统永远在0-1之间——除非采用开链策略。</p>
<p>若当hash function计算出某个元素的插入位置，而该位置上空间已不再可用时，我们需要循序往下一一寻找(如果到达尾端，就绕到头部继续寻找)，直到找到一个可用空间为止。只要表格足够大，总是能够找到一个可以插入的空间。而元素的删除，必须要采用<strong>惰性删除</strong>，也就只标记删除记号，实际删除操作则待表格重新整理时再进行——这是因为hash table中的每一个元素不仅表述它自己，也关系到其它元素的排列。</p>
<p><img src="/posts/800d7d1c/image-20221004191752187-16648822733047.png" alt="image-20221004191752187"></p>
<h3 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h3><p>二次探测主要用来解决线性探测频繁碰撞的问题。其方程为</p>
<script type="math/tex; mode=display">
F(i)=i^2</script><p>如果hash function 计算出新元素的位置为H，而该位置实际上已被使用，那么我们依序尝试$H+1^2$，</p>
<p><script type="math/tex">H+2^2</script>，<script type="math/tex">H+3^2</script>。</p>
<p><img src="/posts/800d7d1c/image-20221004192243391-16648825644668.png" alt="image-20221004192243391"></p>
<p>如果我们假设表格大小为质数，而且永远保持负载系统在0.5以下(也就是超过0.5就重新配置并重新整理表格)，那么就可确实每插入一个新元素所需要探测次数不多于2。</p>
<p>二次探测可以消除主集团(频率碰撞)，即可能造成次集团：两个元素经hash funciton计算出来的位置若相同，则插入时所探测的位置也相同，形成某种浪费。</p>
<h3 id="开链"><a href="#开链" class="headerlink" title="开链"></a>开链</h3><p>开链是在每一个表格元素中维护一个list：hash function 为我们分配某一个List，然后我们在那个List身上执行元素的插入、搜寻、删除等操作。</p>
<h3 id="hash-table的桶子与节点"><a href="#hash-table的桶子与节点" class="headerlink" title="hash table的桶子与节点"></a>hash table的桶子与节点</h3><p><img src="/posts/800d7d1c/image-20221004193023321-16648830243649.png" alt="image-20221004193023321"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash table的定义</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">Value</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">_hashtable_node</span>&#123;</span><br><span class="line">	_hashtable_node*next;</span><br><span class="line">	Value value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20221004193140195-166488310112010.png" alt="image-20221004193140195"></p>
<h3 id="hashtable的迭代器"><a href="#hashtable的迭代器" class="headerlink" title="hashtable的迭代器"></a>hashtable的迭代器</h3><p><img src="/posts/800d7d1c/image-20221004193707144-166488342835411.png" alt="image-20221004193707144"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">V,<span class="symbol">class</span></span> <span class="symbol">K,<span class="symbol">class</span></span> <span class="symbol">HF,<span class="symbol">class</span></span> <span class="symbol">ExK,<span class="symbol">class</span></span> <span class="symbol">EqK,<span class="symbol">class</span></span> <span class="symbol">A</span>&gt;</span><br><span class="line"><span class="symbol">_hashtable_iterator</span>&lt;<span class="symbol">V,<span class="symbol">K</span>,<span class="symbol">HF</span>,<span class="symbol">ExK</span>,<span class="symbol">EqK</span>,<span class="symbol">A</span></span>&gt;&amp;</span><br><span class="line"><span class="symbol">_hashtable_iterator</span>&lt;<span class="symbol">V,<span class="symbol">K</span>,<span class="symbol">HF</span>,<span class="symbol">ExK</span>,<span class="symbol">EqK</span>,<span class="symbol">A</span></span>&gt;::<span class="symbol">operator</span>++()&#123;</span><br><span class="line">	<span class="keyword">const</span> node*old=cur;</span><br><span class="line">	cur=cur-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(!cur)&#123;<span class="comment">//当前桶子只有一个元素</span></span><br><span class="line">		<span class="comment">//根据元素值，定义出下一个bucket，其起头处就是我们的目的地</span></span><br><span class="line">		size_type bucket=ht-&gt;bkt_num(old-&gt;val);</span><br><span class="line">		<span class="keyword">while</span>(!cur&amp;&amp;++bucket&lt;ht-&gt;buckets.size())</span><br><span class="line">			cur=ht-&gt;buckets[bucket];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashtable的数据结构"><a href="#hashtable的数据结构" class="headerlink" title="hashtable的数据结构"></a>hashtable的数据结构</h3><p><img src="/posts/800d7d1c/image-20221004194834846-166488411607512.png" alt="image-20221004194834846"></p>
<p><img src="/posts/800d7d1c/image-20221004195404395-166488444547013.png" alt="image-20221004195404395"></p>
<h3 id="hashtable的构造与内存管理"><a href="#hashtable的构造与内存管理" class="headerlink" title="hashtable的构造与内存管理"></a>hashtable的构造与内存管理</h3><p><img src="/posts/800d7d1c/image-20221004195613720-166488457492514.png" alt="image-20221004195613720"></p>
<h4 id="插入操作-insert-与表格重整-resize"><a href="#插入操作-insert-与表格重整-resize" class="headerlink" title="插入操作(insert)与表格重整(resize)"></a>插入操作(insert)与表格重整(resize)</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素，不允许重复</span></span><br><span class="line">pair&lt;iterator,<span class="built_in">bool</span>&gt;insert_unique(<span class="keyword">const</span> value_type&amp;obj)&#123;</span><br><span class="line">	resize(num_elements+<span class="number">1</span>);<span class="comment">//判断是否需要重建表格，如需要就扩充</span></span><br><span class="line">	<span class="keyword">return</span> insert_unique_noresize(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下函数判断是否需要重建表格,如果不需要，立刻回返，如果需要，就手动</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">V,<span class="symbol">class</span></span> <span class="symbol">K,<span class="symbol">class</span></span> <span class="symbol">HF,<span class="symbol">class</span></span> <span class="symbol">Ex,<span class="symbol">class</span></span> <span class="symbol">Eq,<span class="symbol">class</span></span> <span class="symbol">A</span>&gt;</span><br><span class="line"><span class="symbol">void</span> <span class="symbol">hashtable</span>&lt;<span class="symbol">V,<span class="symbol">K</span>,<span class="symbol">HF</span>,<span class="symbol">Ex</span>,<span class="symbol">Eq</span>,<span class="symbol">A</span></span>&gt;::<span class="symbol">resize</span>(<span class="symbol">size_type</span> <span class="symbol">num_elements_hint</span>)&#123;</span><br><span class="line">	<span class="comment">//以下，“表格重建与否”的判断原则是拿元素个数(把新增元素计入后)和</span></span><br><span class="line">	<span class="comment">//bucket vector的大小来比，如果前者大于后者，就重建表格</span></span><br><span class="line">	<span class="keyword">const</span> size_type old_n=buckets.size();</span><br><span class="line">	<span class="keyword">if</span>(num_elements_hint&gt;old_n)&#123;<span class="comment">//需要重新配置</span></span><br><span class="line">		<span class="keyword">const</span> size_type n=next_size(num_elements_hint);<span class="comment">//找出下一个质数 </span></span><br><span class="line">		<span class="keyword">if</span>(n&gt;old_n)&#123;</span><br><span class="line">			vector&lt;node*,A&gt;temp(n,(node*)<span class="number">0</span>);<span class="comment">//设立新的buckets</span></span><br><span class="line">			<span class="keyword">for</span>(size_type bucket=<span class="number">0</span>;bucket&lt;old_n;bucket++)&#123;</span><br><span class="line">				node*first=buckets[bucket];<span class="comment">//指向桶的起始节点</span></span><br><span class="line">				<span class="comment">//以下处理旧桶中的每一个节点，把每个桶中的节点移到新桶中</span></span><br><span class="line">				<span class="keyword">while</span>(first)&#123;</span><br><span class="line">					<span class="comment">//找出节点落在哪一个新bucket内</span></span><br><span class="line">					size_type new_bucket=bkt_num(first-&gt;val,n);</span><br><span class="line">					<span class="comment">//令旧bucket指向其所应之串行的下一个节点</span></span><br><span class="line">					buckets[bucket]=first-&gt;next;</span><br><span class="line">					<span class="comment">//将当前节点插入到新bucket内，成为其对应串行的第一个节点</span></span><br><span class="line">					first-&gt;next=temp[new_bucket];</span><br><span class="line">					temp[new_bucket]=first;</span><br><span class="line">					<span class="comment">//处理下一个节点</span></span><br><span class="line">					first=buckets[bucket];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bucket.swap(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20221004202034325-166488603569715.png" alt="image-20221004202034325"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不需重建表格的情况下插入新节点，键值不允许重复</span></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">V,<span class="symbol">class</span></span> <span class="symbol">K,<span class="symbol">class</span></span> <span class="symbol">HF,<span class="symbol">class</span></span> <span class="symbol">Ex,<span class="symbol">class</span></span> <span class="symbol">Eq,<span class="symbol">class</span></span> <span class="symbol">A</span>&gt;</span><br><span class="line"><span class="symbol">pair</span>&lt;<span class="symbol">typename</span> <span class="symbol">hashTable</span>&lt;<span class="symbol">V,<span class="symbol">K</span>,<span class="symbol">HF</span>,<span class="symbol">Ex</span>,<span class="symbol">Eq</span>,<span class="symbol">A</span></span>&gt;::<span class="symbol">iterator,<span class="symbol">bool</span></span>&gt;</span><br><span class="line"><span class="symbol">hashtable</span>&lt;<span class="symbol">V,<span class="symbol">K</span>,<span class="symbol">HF</span>,<span class="symbol">Ex</span>,<span class="symbol">Eq</span>,<span class="symbol">A</span></span>&gt;::<span class="symbol">insert_unique_noresize</span>(<span class="symbol">const</span> <span class="symbol">value_type</span>&amp;<span class="symbol">obj</span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> size_type n=bkt_num(obj);</span><br><span class="line">	node*first=buckets[n];<span class="comment">//令first指向bucket对应之串行头部</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果buckets[n]已被占用，此时first将不为，于是进行以下循环</span></span><br><span class="line">	<span class="comment">//走过bucket所对应的链表</span></span><br><span class="line">	<span class="keyword">for</span>(node*cur=first;cur;cur=cur-&gt;next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(equals(get_key(cur_val),get_key(obj)))</span><br><span class="line">		<span class="comment">//如果发现与链表中的某键值相同，就不插入，立刻返回</span></span><br><span class="line">			<span class="keyword">return</span> pair&lt;iterator,<span class="built_in">bool</span>&gt;(iterator(cur,<span class="keyword">this</span>),<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	node*temp=new_node(obj);<span class="comment">//产生新节点</span></span><br><span class="line">	temp-&gt;next=first;</span><br><span class="line">	buckets[n]=temp;<span class="comment">//令节点成为链表的第一节点</span></span><br><span class="line">	++num_elements;</span><br><span class="line">	<span class="keyword">return</span> pair&lt;iterator,<span class="built_in">bool</span>&gt;(iterator(temp,<span class="keyword">this</span>),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/800d7d1c/image-20221004203111277-166488667210416.png" alt="image-20221004203111277"></p>
<p><img src="/posts/800d7d1c/image-20221004203129755-166488669095217.png" alt="image-20221004203129755"></p>
<h4 id="判知元素的落脚处"><a href="#判知元素的落脚处" class="headerlink" title="判知元素的落脚处"></a>判知元素的落脚处</h4><p><img src="/posts/800d7d1c/image-20221004203249845-166488677162218.png" alt="image-20221004203249845"></p>
<h4 id="复制和整体删除"><a href="#复制和整体删除" class="headerlink" title="复制和整体删除"></a>复制和整体删除</h4><p><img src="/posts/800d7d1c/image-20221004203338447-166488682004419.png" alt="image-20221004203338447"></p>
<p><img src="/posts/800d7d1c/image-20221004203628047-166488698937620.png" alt="image-20221004203628047"></p>
<p><img src="/posts/800d7d1c/image-20221004203645314-166488700653521.png" alt="image-20221004203645314"></p>
<p><img src="/posts/800d7d1c/image-20221004203707502-166488702894922.png" alt="image-20221004203707502"></p>
<h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><p>仿函数是一个“行为类似函数”的对象</p>
<p><img src="/posts/800d7d1c/image-20221005154615702-16649559775411.png" alt="image-20221005154615702"></p>
<p><img src="/posts/800d7d1c/image-20221005154647302-16649560082712.png" alt="image-20221005154647302"></p>
<p><img src="/posts/800d7d1c/image-20221005154656216-16649560171793.png" alt="image-20221005154656216"></p>
<h2 id="可配接的关系"><a href="#可配接的关系" class="headerlink" title="可配接的关系"></a>可配接的关系</h2><p>若仿函数要融入STL中，则需要有配接能力。</p>
<h2 id="unary-function"><a href="#unary-function" class="headerlink" title="unary_function"></a>unary_function</h2><p>unary_faction 用来呈现一元函数的参数型别和回返值型别 。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">Arg,<span class="symbol">class</span></span> <span class="symbol">Result</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">unary_function</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦某个仿函数继承了unary_function，其用户便可以取得这样的仿函数的参数型别，并以相同手法取得其回返值型别。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">negate:<span class="symbol">public</span></span> <span class="symbol">unary_function</span>&lt;<span class="symbol">T,<span class="symbol">T</span></span>&gt;&#123;</span><br><span class="line">	T operator()(<span class="keyword">const</span> T&amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> -x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="binary-function"><a href="#binary-function" class="headerlink" title="binary_function"></a>binary_function</h2><p>binary_function用来呈现二元函数的第一参数型别、第二参数型别以及返回值型别。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">Arg1,<span class="symbol">class</span></span> <span class="symbol">Arg2,<span class="symbol">class</span></span> <span class="symbol">Result</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">binary_function</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">plus:<span class="symbol">public</span></span> <span class="symbol">binary_function</span>&lt;<span class="symbol">T,<span class="symbol">T</span>,<span class="symbol">T</span></span>&gt;&#123;</span><br><span class="line">	T operator()(<span class="keyword">const</span> T&amp;x,<span class="keyword">const</span> T&amp;y)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算术类仿函数"><a href="#算术类仿函数" class="headerlink" title="算术类仿函数"></a>算术类仿函数</h2><p><img src="/posts/800d7d1c/image-20221005155827733-16649567091324.png" alt="image-20221005155827733"></p>
<p><img src="/posts/800d7d1c/image-20221005160216201-16649569372425.png" alt="image-20221005160216201"></p>
<h2 id="关系运算类仿函数"><a href="#关系运算类仿函数" class="headerlink" title="关系运算类仿函数"></a>关系运算类仿函数</h2><p><img src="/posts/800d7d1c/image-20221005160321422-16649570024816.png" alt="image-20221005160321422"></p>
<h2 id="逻辑类仿函数"><a href="#逻辑类仿函数" class="headerlink" title="逻辑类仿函数"></a>逻辑类仿函数</h2><p><img src="/posts/800d7d1c/image-20221005160412084-16649570531097.png" alt="image-20221005160412084"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/STL/" rel="tag"># STL</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/165d148b/" rel="prev" title="C++线程池">
      <i class="fa fa-chevron-left"></i> C++线程池
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/30479bcf/" rel="next" title="Effective C++">
      Effective C++ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A6%82%E5%BF%B5%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">迭代器概念与traits编程技法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%B8%80%E7%A7%8Dsmart-pointer"><span class="nav-number">1.1.</span> <span class="nav-text">迭代器是一种smart pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">Traits编程技法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%B8%80-value-type"><span class="nav-number">1.2.1.</span> <span class="nav-text">迭代器型别之一:value type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%BA%8C-difference-type"><span class="nav-number">1.2.2.</span> <span class="nav-text">迭代器型别之二: difference type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%B8%89%EF%BC%9Areference-type"><span class="nav-number">1.2.3.</span> <span class="nav-text">迭代器型别之三：reference type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9E%8B%E5%88%AB%E4%B9%8B%E5%9B%9B%EF%BC%9Apointer-type"><span class="nav-number">1.2.4.</span> <span class="nav-text">迭代器型别之四：pointer type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%BA%94%EF%BC%9Aiterator-category"><span class="nav-number">1.2.5.</span> <span class="nav-text">迭代器型别之五：iterator_category</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-iterator-%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-number">1.2.6.</span> <span class="nav-text">std::iterator 的保证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterator%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%8C%E6%95%B4%E9%87%8D%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">iterator源代码完整重列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">序列式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">vector容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">vector定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.1.2.</span> <span class="nav-text">vector的构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector%E7%9A%84%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%EF%BC%9Apop-back-erase-clear-insert"><span class="nav-number">2.1.3.</span> <span class="nav-text">vector的元素操作：pop_back,erase,clear,insert</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E5%AE%B9%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">List容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.1.</span> <span class="nav-text">list节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.2.2.</span> <span class="nav-text">list的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E7%9A%84%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.3.</span> <span class="nav-text">list的元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque%E5%AE%B9%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">deque容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#deque%E7%9A%84%E4%B8%AD%E6%8E%A7%E5%99%A8"><span class="nav-number">2.3.1.</span> <span class="nav-text">deque的中控器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.3.2.</span> <span class="nav-text">deque的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.3.</span> <span class="nav-text">deque的数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#heap-%E5%A0%86"><span class="nav-number">2.4.</span> <span class="nav-text">heap(堆)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#priority-queue"><span class="nav-number">2.5.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slist"><span class="nav-number">2.6.</span> <span class="nav-text">slist</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#slit%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.6.1.</span> <span class="nav-text">slit的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slist%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.6.2.</span> <span class="nav-text">slist迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slist%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.6.3.</span> <span class="nav-text">slist的数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.1.</span> <span class="nav-text">平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AVL-tree"><span class="nav-number">3.1.1.</span> <span class="nav-text">AVL tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%97%8B%E8%BD%AC"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">单旋转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%97%8B%E8%BD%AC"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">双旋转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">3.1.2.</span> <span class="nav-text">2-3查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3%E6%A0%91%E7%9A%84%E5%8F%98%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">2-3树的变化过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">2-3树的构造过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">2-3查找树的删除过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">3.1.3.</span> <span class="nav-text">红黑二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">红黑树的另一种定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E8%A1%A8%E7%A4%BA"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">颜色表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">旋转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E6%A0%91%E5%BA%95%E9%83%A8%E7%9A%842-%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E5%BB%BA"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">向树底部的2-结点插入新建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E4%B8%80%E6%A3%B5%E5%8F%8C%E9%94%AE%E6%A0%91-%E5%8D%B3%E4%B8%80%E4%B8%AA3-%E7%BB%93%E7%82%B9-%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="nav-number">3.1.3.5.</span> <span class="nav-text">向一棵双键树(即一个3-结点)中插入新键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.1.3.6.</span> <span class="nav-text">颜色转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E6%A0%91%E5%BA%95%E9%83%A8%E7%9A%843-%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="nav-number">3.1.3.7.</span> <span class="nav-text">向树底部的3-结点插入新键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.3.8.</span> <span class="nav-text">插入实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%842-3-4%E6%A0%91"><span class="nav-number">3.1.3.9.</span> <span class="nav-text">自顶向下的2-3-4树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E9%94%AE"><span class="nav-number">3.1.3.10.</span> <span class="nav-text">删除最小键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%A7%E9%94%AE"><span class="nav-number">3.1.3.11.</span> <span class="nav-text">删除最大键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.3.12.</span> <span class="nav-text">删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RB-Tree%E7%9A%84%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.1.3.13.</span> <span class="nav-text">RB-Tree的节点设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RB-tree%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.3.14.</span> <span class="nav-text">RB-tree的数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set"><span class="nav-number">3.2.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map"><span class="nav-number">3.3.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multiSet"><span class="nav-number">3.4.</span> <span class="nav-text">multiSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multiMap"><span class="nav-number">3.5.</span> <span class="nav-text">multiMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashtable-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">3.6.</span> <span class="nav-text">hashtable(哈希表)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B"><span class="nav-number">3.6.1.</span> <span class="nav-text">线性探测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B"><span class="nav-number">3.6.2.</span> <span class="nav-text">二次探测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E9%93%BE"><span class="nav-number">3.6.3.</span> <span class="nav-text">开链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash-table%E7%9A%84%E6%A1%B6%E5%AD%90%E4%B8%8E%E8%8A%82%E7%82%B9"><span class="nav-number">3.6.4.</span> <span class="nav-text">hash table的桶子与节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.6.5.</span> <span class="nav-text">hashtable的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.6.6.</span> <span class="nav-text">hashtable的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">3.6.7.</span> <span class="nav-text">hashtable的构造与内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-insert-%E4%B8%8E%E8%A1%A8%E6%A0%BC%E9%87%8D%E6%95%B4-resize"><span class="nav-number">3.6.7.1.</span> <span class="nav-text">插入操作(insert)与表格重整(resize)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E7%9F%A5%E5%85%83%E7%B4%A0%E7%9A%84%E8%90%BD%E8%84%9A%E5%A4%84"><span class="nav-number">3.6.7.2.</span> <span class="nav-text">判知元素的落脚处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%92%8C%E6%95%B4%E4%BD%93%E5%88%A0%E9%99%A4"><span class="nav-number">3.6.7.3.</span> <span class="nav-text">复制和整体删除</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">仿函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%85%8D%E6%8E%A5%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.1.</span> <span class="nav-text">可配接的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unary-function"><span class="nav-number">4.2.</span> <span class="nav-text">unary_function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binary-function"><span class="nav-number">4.3.</span> <span class="nav-text">binary_function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">算术类仿函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.</span> <span class="nav-text">关系运算类仿函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">4.6.</span> <span class="nav-text">逻辑类仿函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘王权</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangquanliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangquanliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/liuwangquan@163.com" title="E-Mail → liuwangquan@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘王权</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">151k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:17</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
